\input texinfo.tex
@c %**start of header
@setfilename vicare-sqlite.info
@settitle SQLite backend for Vicare Scheme
@c %**end of header

@include version.texi
@include macros.texi

@macro blob{}
@acronym{BLOB}
@end macro

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      SQLite backend for Vicare Scheme

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Vicare/SQLite

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           vicare-sqlite

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi.ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2012

@set TESTED_SQLITE_VERSION      3.7.13

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @version{} of @value{PACKAGE}, a
distribution of C and Scheme libraries for Vicare Scheme, an @rnrs{6}
compliant Scheme implementation; it provides bindings for the SQLite
@sql{} database engine.  The last time the maintainer bothered to update
this paragraph, he had tested SQLite Amalgamation version
@value{TESTED_SQLITE_VERSION}.

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}) and can be downloaded from:

@center @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}

@noindent
the home page of the Vicare project is at:

@center @url{http://marcomaggi.github.com/vicare.html}

@noindent
the home page of SQLite is at:

@center @url{http://www.sqlite.org/}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* vicare-sqlite: (vicare-sqlite). @value{TITLE}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* plain::                       Plain interface to SQLite.

Appendices

* Package License::             @gnu{} General Public License.
* Documentation License::       @gnu{} Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


Vicare Scheme is an @rnrs{6} compliant Scheme language implementation in
the form of a native compiler for x86 architectures, officially
supporting @gnu{}+Linux systems.  @value{PACKAGE} is a distribution of C
language and Scheme language libraries for Vicare Scheme; it provides
bindings for the SQLite @sql{} database engine.  The last time the
maintainer bothered to update this paragraph, he had tested SQLite
Amalgamation version @value{TESTED_SQLITE_VERSION}.

SQLite is a in--process library that implements a self--contained,
serverless, zero--configuration, transactional @sql{} database engine.
The code for SQLite is in the public domain and is thus free for use for
any purpose, commercial or private.

The package installs a C language library implementing wrapper C
functions for the C language SQLite library; on top of this, a set of
Scheme libraries exports an adapted @api{}.  This document contains only
a brief description of the functions: refer to the SQLite's
documentation for details:

@center @url{http://www.sqlite.org/c3ref/intro.html}

The following Scheme libraries are installed:

@table @library
@item vicare databases sqlite3
It exports one binding for each SQLite public function.  All the Scheme
function names are directly derived from the C function names by
replacing underscore characters @samp{_} with dash characters @samp{-};
so @cfunc{sqlite3_exec} becomes @func{sqlite3-exec}.

@item vicare databases sqlite3 unsafe-capi
It exports one syntax binding for each SQLite public function.  All the
Scheme syntax names are directly derived from the C function names by
replacing underscore characters @samp{_} with dash characters @samp{-};
so @cfunc{sqlite3_exec} becomes @func{sqlite3-exec}.

These syntaxes expand to a direct call to the C language wrapper
functions in the @value{PACKAGE} library; they are not meant to be
called in normal usage of the package.

@item vicare databases sqlite3 constants
It exports one binding for each constant value defined in the C language
header @file{sqlite3.h}.

@item vicare databases sqlite3 features
It exports one identifier syntax binding for each @code{HAVE_} constant
defined by the @command{configure} script, expanding to @true{} or
@false{}.
@end table

After installation, under the directory @code{$libexecdir/$PACKAGE}, a
script @file{compile-all.sps} can be executed to precompile the
installed libraries; for example:

@example
$ sudo vicare --compile-dependencies \
   /usr/local/libexec/vicare-sqlite/compile-all.sps
@end example

@c page
@node plain
@chapter Plain interface to SQLite


@menu
* plain library::               Library initialisation and finalisation.
* plain version::               Version informations.
* plain compile options::       Inspecting SQLite compile options.
* plain connect::               Handling database connections.
* plain exec::                  Simple execution of @sql{} snippets.
* plain get table::             Simple retrieval of table from @sql{}
                                snippets.
* plain statements::            Prepared @sql{} statements.
* plain blobs::                 @blob{}s for incremental input/output.
* plain sql aux::               @sql{} execution auxiliary functions.
* plain hooks::                 Notification hooks.
* plain errors::                Error codes and error messages.
* plain extensions::            Loading SQLite extensions.
* plain functions::             Extending @sql{} with custom functions.
* plain misc::                  Miscellaneous functions.
@end menu

@c page
@node plain library
@section Library initialisation and finalisation


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-initialize
Initialise the SQLite library.  If successful return @code{SQLITE_OK},
else return an error code.
@end defun


@defun sqlite3-shutdown
Deallocate any resources that were allocated by
@func{sqlite3-initialize}.  If successful return @code{SQLITE_OK}, else
return an error code.
@end defun


@defun sqlite3-os-init
Do operating--system specific initialization of the SQLite library.  If
successful return @code{SQLITE_OK}, else return an error code.
@end defun


@defun sqlite3-os-end
Undo the effect of @func{sqlite3-os-init}.  If successful return
@code{SQLITE_OK}, else return an error code.
@end defun


@defun sqlite3-config @var{option-identifier} @var{arg} ...
Make global configuration changes to SQLite in order to tune SQLite to
the specific needs of the application.  When successful return
@code{SQLITE_OK}, else return a @code{SQLITE_} error code.

@var{option-identifier} must be a fixnum representing a
@code{SQLITE_CONFIG_} constant.  If the identifier is not recognised:
the return value is @code{SQLITE_ERROR}.

The optional @var{arg} depend on the selected option; if the number and
type of arguments is invalid: the return value is @code{SQLITE_ERROR}.

@table @code
@item SQLITE_CONFIG_SINGLETHREAD
Accept no additional arguments.

@item SQLITE_CONFIG_MULTITHREAD
Accept no additional arguments.

@item SQLITE_CONFIG_SERIALIZED
Accept no additional arguments.

@item SQLITE_CONFIG_MALLOC
Accept a pointer object as single argument.

@item SQLITE_CONFIG_GETMALLOC
Accept a pointer object as single argument.

@item SQLITE_CONFIG_SCRATCH
Accept @math{3} arguments: a pointer, a fixnum, a fixnum.

@item SQLITE_CONFIG_PAGECACHE
Accept @math{3} arguments: a pointer, a fixnum, a fixnum.

@item SQLITE_CONFIG_HEAP
Accept @math{3} arguments: a pointer, a fixnum, a fixnum.

@item SQLITE_CONFIG_MEMSTATUS
Accept a value interpreted as boolean.

@item SQLITE_CONFIG_MUTEX
Accept a pointer object as single argument.

@item SQLITE_CONFIG_GETMUTEX
Accept a pointer object as single argument.

@item SQLITE_CONFIG_LOOKASIDE
Accept @math{3} arguments: a fixnum, a fixnum.

@item SQLITE_CONFIG_PCACHE
@itemx SQLITE_CONFIG_GETPCACHE
These options are obsolete: using them causes no action to be taken.

@item SQLITE_CONFIG_LOG
Accept a pointer object referencing a callback function as single
argument.  Always set to @cnull{} the custom @code{void *} argument to
the callback.

@quotation
@strong{NOTE} The log callback can be registered and unregistered only
before initialising the SQLite library; so either we set it before doing
anything else or we call @func{sqlite3-shutdown} and then
@func{sqlite3-config}.
@end quotation

@item SQLITE_CONFIG_URI
Accept a value interpreted as boolean.

@item SQLITE_CONFIG_PCACHE2
Accept a pointer object as single argument.

@item SQLITE_CONFIG_GETPCACHE2
Accept a pointer object as single argument.
@end table
@end defun

@c ------------------------------------------------------------

@defun sqlite3-memory-used
Return an exact integer representing number of bytes of memory currently
outstanding (malloced but not freed).
@end defun


@defun sqlite3-memory-highwater @var{reset}
Return an exact integer representing the maximum value of
@func{sqlite3-memory-used} since the high--water mark was last reset.
@var{reset} is interpreted as boolean: if true reset the value, if
@false{} do not.
@end defun

@c ------------------------------------------------------------

@defun sqlite3-enable-shared-cache @var{bool}
Enable or disable the sharing of the database cache and schema data
structures between connections to the same database; sharing is enabled
if the argument is true and disabled if the argument is false.  If
successful return @code{SQLITE_OK}, else return a @code{SQLITE_} error
code.
@end defun


@defun sqlite3-release-memory @var{number-of-bytes}
Attempt to free @var{number-of-bytes} bytes of heap memory by
deallocating non--essential memory allocations held by the database
library.  Return an exact integer representing the number of bytes
actually freed, which might be more or less than the amount requested.
@end defun


@defun sqlite3-soft-heap-limit64 @var{limit}
Set and/or query the soft limit on the amount of heap memory that may be
allocated by SQLite.  Return a non--negative exact integer representing
the size of the soft heap limit prior to the call, or a negative exact
integer in the case of an error.

@var{limit} must be an exact integer:

@itemize
@item
When negative: no change is made and the returned value represents the
current limit.

@item
When zero: the limit is disabled.

@item
When positive: @var{limit} represents the new limit.
@end itemize
@end defun


@defun sqlite3-soft-heap-limit @var{limit}
Deprecated version of @func{sqlite3-soft-heap-limit}.
@end defun

@c page
@node plain version
@section Version informations


The installed C library follows version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.  The following
bindings are exported by the @library{vicare databases sqlite3} library.


@defun vicare-sqlite3-version-string
Return a string representing the @value{PACKAGE} C library interface
version number, not to be confused with the package version number.
@end defun


@defun vicare-sqlite3-version-interface-current
Return a fixnum representing the @value{PACKAGE} C library interface
current version number.
@end defun


@defun vicare-sqlite3-version-interface-revision
Return an integer representing the @value{PACKAGE} C library interface
current revision number.
@end defun


@defun vicare-sqlite3-version-interface-age
Return an integer representing the @value{PACKAGE} C library interface
current age.
@end defun


@defun sqlite3-libversion
Return a string representing the version number of the SQLite library in
use.
@end defun


@defun sqlite3-sourceid
Return a string representing the source identifier the SQLite library in
use.
@end defun

@c page
@node plain compile options
@section Inspecting SQLite compile options


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-compileoption-get @var{option-index}
Return a string representing the name of the SQLite option at
@var{option-index} that was enabled at compile time; if the index is out
of range: return @false{}.

@example
#!r6rs
(import (vicare)
  (vicare databases sqlite3))

(let loop ((i  0)
           (op (sqlite3-compileoption-get 0)))
  (and op
       (begin
         (printf "~a\n" op)
         (let ((i (+ 1 i)))
           (loop i (sqlite3-compileoption-get i))))))
@print{} "CURDIR"
@print{} "ENABLE_FTS3"
@print{} "ENABLE_RTREE"
@print{} "TEMP_STORE=1"
@print{} "THREADSAFE=1"
@end example
@end defun


@defun sqlite3-compileoption-used @var{option-name}
Return @true{} if the SQLite compile option @var{option-name}, which
must be a string, is enabled.

@example
#!r6rs
(import (vicare)
  (vicare databases sqlite3))

(sqlite3-compile-option-used "CURDIR")
@result{} #t
@end example
@end defun


@defun sqlite3-threadsafe
Return @true{} if SQLite was compiled with thread--safe features
enabled.
@end defun

@c page
@node plain connect
@section Handling database connections


@menu
* plain connect struct::        Data structure representing
                                connections.
* plain connect open::          Opening and closing connections.
* plain connect config::        Database connection configuration.
* plain connect busy::          Setting a connection--busy handler.
* plain connect trace::         Tracing database connection operations.
* plain connect profile::       Profiling @sql{} statements execution.
* plain connect inspect::       Inspecting database connections.
* plain connect auth::          Controlling access to data.
* plain connect misc::          Miscellaneous connection operations.
@end menu

@c page
@node plain connect struct
@subsection Data structure representing connections


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@deftp {Struct Type} sqlite3
@cindex @var{connection} argument
@cindex Argument @var{connection}
An opaque Scheme structure holding a reference to an instance of the C
language type @code{sqlite3}, it references a connection to a SQLite
database.  @vicareref{iklib structs, Structures and type descriptors}

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{connection}.

There are two categories of @code{sqlite3} instances: those who own the
underlying database connection and those who merely reference it.

@itemize
@item
@code{sqlite3} instances returned by @func{sqlite3-open-v2} (and
similar) and by @func{sqlite3-db-handle} do own the database connection.
When instances of this category are garbage collected or when
@func{sqlite3-close} is applied to them: the database connection is
closed, all the associated @code{sqlite3-stmt} instances are finalised
and all the associated @code{sqlite3-blob} instances are closed; any
error is ignored in this procedure.

@item
@code{sqlite3} instances returned by @func{sqlite3-context-db-handle} do
@strong{not} own the database connection.  When instances of this
category are garbage collected or when @func{sqlite3-close} is applied
to them: the database connection left open, all the associated
@code{sqlite3-stmt} instances are finalised and all the associated
@code{sqlite3-blob} instances are closed; any error is ignored in this
procedure.
@end itemize
@end deftp


@defun sqlite3? @var{obj}
Return @true{} if @var{obj} is an instance of @code{sqlite3}.
@end defun


@defun sqlite3?/open @var{obj}
Return @true{} if @var{obj} is an instance of @code{sqlite3} and the
connection it represents is open.
@end defun


@defun sqlite3-destructor @var{connection}
@defunx set-sqlite3-destructor! @var{connection} @var{func}
Retrieve or set a destructor function associated to the
@var{connection}.

Whenever the @var{connection} is closed, either explicitly with
@func{sqlite3-close} or implicitly by the garbage collector, @var{func}
is applied to @var{connection} before the internal state of
@var{connection} is finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{connection};  If we do:

@example
(define connection ...)
(set-sqlite3-destructor! connection
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((conn)
       (destroy state))
      ((conn dummy)
       state))))

(let ((state ((sqlite3-destructor connection #t) connection)))
  (do-something-with connection state))
@end example

@noindent
we can easily associate values to @var{connection}.
@end defun

@c page
@node plain connect open
@subsection Opening and closing connections


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-close @var{connection}
Close the database connection referenced by @var{connection}, which must
be an instance of @code{sqlite3}.  Return an exact integer representing
a @code{SQLITE_} constant.

It is safe to apply multiple times this function to the same
@var{connection}: the first time the connection is closed, the
subsequent times nothing happens and the return value is
@code{SQLITE_OK}.

This function finalises all the statements associated to
@var{connection} and closes all the @blob{}s associated to
@var{connection}.
@end defun


@defun sqlite3-open @var{pathname}
@defunx sqlite3-open16 @var{pathname}
Open a new database connection to the file selected by the
@var{pathname}, which must be a string or bytevector; if successful
return a new instance of @code{sqlite3}, else return a @code{SQLITE_}
constant.

@quotation
@strong{NOTE} It appears that SQLite's idea of zero--terminated
@utf{}-16 array means that the array must end with @math{2} zero bytes.
So to obtain a suitable @utf{}-16 bytevector pathname from a string we
should do:

@example
(bytevector-append (string->utf16n pathname)
                   '#vu8(0 0))
@end example

This is exactly what @func{sqlite3-open16} does when @var{pathname} is a
string.
@end quotation

The following example shows how to open and close a database:

@example
#!r6rs
(import (vicare)
  (vicare databases sqlite3)
  (only (vicare syntactic-extensions)
        unwind-protect))

(let ((conn (sqlite3-open "sqlite.test.db")))
  (unwind-protect
      (sqlite3?/open conn)
    (when (sqlite3? conn)
      (sqlite3-close conn))))
@result{} #t ;if successful
@end example
@end defun


@defun sqlite3-open-v2 @var{pathname} @var{flags}
@defunx sqlite3-open-v2 @var{pathname} @var{flags} @var{vfs-module}
Open a new database connection to the file selected by the
@var{pathname}, which must be a string or bytevector; if successful
return a new instance of @code{sqlite3}, else return a @code{SQLITE_}
constant.

To create a private, temporary, in--memory database we must use
@code{:memory:} as @var{pathname}.

@var{flags} must be an exact integer representing database configuration
flags.  The optional @var{vfs-module} must be @false{} or a pointer
object or a @utf{}-8 bytevector or a string representing the name of a
@acronym{VFS} module; when @false{} or not given: the default module is
used.

@example
#!r6rs
(import (vicare)
  (vicare databases sqlite3)
  (only (vicare syntactic-extensions)
        unwind-protect))

(let ((conn (sqlite3-open-v2 "sqlite.test.db"
                             (fxior SQLITE_OPEN_READWRITE
                                    SQLITE_OPEN_CREATE))))
  (unwind-protect
      (sqlite3?/open conn)
    (when (sqlite3? conn)
      (sqlite3-close conn))))
@result{} #t ;if successful
@end example
@end defun

@c page
@node plain connect config
@subsection Database connection configuration


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-db-config @var{connection} @var{option-identifier} @var{arg} ...
Make configuration changes to a database @var{connection}.  The default
for the options is: when successful return @code{SQLITE_OK}, else return
a @code{SQLITE_} error code; see the documentation of each option for
special cases.

@var{option-identifier} must be a fixnum representing a
@code{SQLITE_DBCONFIG_} constant.  If the identifier is not recognised:
the return value is @code{SQLITE_ERROR}.

The optional @var{arg} depend on the selected option; if the number and
type of arguments is invalid: the return value is @code{SQLITE_ERROR}.

@table @code
@item SQLITE_DBCONFIG_LOOKASIDE
Accept @math{3} arguments: a pointer, a fixnum, a fixnum.

@item SQLITE_DBCONFIG_ENABLE_FKEY
Accept a fixnum as single argument.  As a special case: when called with
this option, the function returns a boolean value.

@item SQLITE_DBCONFIG_ENABLE_TRIGGER
Accept a fixnum as single argument.  As a special case: when called with
this option, the function returns a boolean value.
@end table
@end defun


@defun sqlite3-extended-result-codes @var{connection} @var{boolean}
Enable or disable the extended result codes feature of SQLite; the
extended result codes are disabled by default for historical
compatibility.  If successful return @code{SQLITE_OK}, else return a
@code{SQLITE_} error code.

If @var{boolean} is @false{}: extended result codes are disabled; else
they are enabled.
@end defun


@defun sqlite3-limit @var{connection} @var{limit-identifier} @var{limit-value}
Allow the size of various constructs to be limited on a connection by
connection basis.  @var{limit-identifier} must be one of the
@code{SQLITE_LIMIT_} constants; @var{limit-value} must be an exact
integer, in the range of the C language type @code{int}, representing
the new limit value.  Return an exact integer representing the previous
limit value.
@end defun

@c page
@node plain connect busy
@subsection Setting a connection--busy handler


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-busy-handler @var{connection}
@defunx sqlite3-busy-handler @var{connection} @var{callback}
Set a callback function that might be invoked whenever an attempt is
made to open a database table that another thread or process has locked;
if successful return @code{SQLITE_OK}, else return a @code{SQLITE_}
error code.

The optional @var{callback} must be a pointer object referencing a
callback produced by @func{make-sqlite3-busy-handler-callback}; when
@false{} or not given: no callback is used and @cnull{} is handed to
@cfunc{sqlite3_busy_handler}.
@end defun


@defun make-sqlite3-busy-handler-callback @var{user-scheme-callback}
Wrap a user supplied Scheme function and return a pointer object
referencing a callback function suitable to be used as @var{callback} in
calls to @func{sqlite3-busy-handler}; the returned pointer must be
released with a call to @func{free-c-callback} from @library{vicare
ffi}.

@var{user-scheme-callback} must accept a single argument: an exact
integer representing the number of times that the busy handler has been
invoked for this locking event.

@var{user-scheme-callback} must return a single value which interpreted
as answer to the question ``retry to access the database?''; when true:
another attempt is made to open the database for reading and the cycle
repeats; when @false{} no additional attempts are made to access the
database.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}; when an exception is catched: it is discarded and the
callback returns @code{0} to the caller.  @var{user-scheme-callback}
should take care of handling its own exceptions.

@item
If @var{user-scheme-callback} returns true: the wrapping callback
returns @code{1} to the caller, else it returns @code{0}.
@end itemize
@end defun


@defun sqlite3-busy-timeout @var{connection} @var{milliseconds}
Set a busy handler that sleeps for a specified amount of time when a
table is locked; if successful return @code{SQLITE_OK} else return a
@code{SQLITE_} error code.

@var{milliseconds} must be a fixnum representing the timeout span in
milliseconds.
@end defun

@c page
@node plain connect trace
@subsection Tracing database connection operations


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-trace @var{connection} @var{callback}
The callback registered by @func{sqlite3-trace} is invoked at various
times when an @sql{} statement is being run by @func{sqlite3-step} for
@var{connection}.  Return unspecified values.

@var{callback} must be @false{} or a a pointer object referencing a
callback produced by @func{make-sqlite3-trace-callback}; when @false{}:
the previously registered callback, if any, is unregistered from the
state of @var{connection}.
@end defun


@defun make-sqlite3-trace-callback @var{user-scheme-function}
Wrap a user supplied Scheme function and return a pointer object
referencing a callback function suitable to be used as second argument
in calls to @func{sqlite3-trace}; the returned pointer must be released
with a call to @func{free-c-callback} from @library{vicare ffi}.

@var{user-scheme-callback} must accept a single argument: a pointer
object referencing a @utf{}-8 byte array rendering of the @sql{}
statement text as the statement first begins executing; such value can
be converted to Scheme with @func{cstring->string} or
@func{cstring->bytevector}.

@var{user-scheme-callback} can return unspecified values.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}; when an exception is catched: it is discarded and the
callback returns the void value.  @var{user-scheme-callback} should take
care of handling its own exceptions.
@end itemize
@end defun

@c page
@node plain connect profile
@subsection Profiling @sql{} statements execution


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-profile @var{connection} @var{callback}
The callback registered by @func{sqlite3-profile} is invoked whenever a
@sql{} statements finishes.  Return unspecified values.

@var{callback} must be @false{} or a a pointer object referencing a
callback produced by @func{make-sqlite3-profile-callback}; when
@false{}: the previously registered callback, if any, is unregistered
from the state of @var{connection}.
@end defun


@defun make-sqlite3-profile-callback @var{user-scheme-function}
Wrap a user supplied Scheme function and return a pointer object
referencing a callback function suitable to be used as second argument
in calls to @func{sqlite3-profile}; the returned pointer must be
released with a call to @func{free-c-callback} from @library{vicare
ffi}.

@var{user-scheme-callback} must accept a @math{2} arguments:

@enumerate
@item
A pointer object referencing a @utf{}-8 byte array rendering of the
@sql{} statement text as the statement finishes executing; such value
can be converted to Scheme with @func{cstring->string} or
@func{cstring->bytevector}.

@item
An exact integer representing the number of nanoseconds the statement
took to be executed.
@end enumerate

@var{user-scheme-callback} can return unspecified values.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}; when an exception is catched: it is discarded and the
callback returns the void value.  @var{user-scheme-callback} should take
care of handling its own exceptions.
@end itemize
@end defun

@c page
@node plain connect inspect
@subsection Inspecting database connections


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-get-autocommit @var{connection}
Return @true{} if the given database @var{connection} is in autocommit
mode, @false{} otherwise; autocommit mode is on by default.
@end defun


@defun sqlite3-db-filename @var{connection} @var{database}
@defunx sqlite3-db-filename/string @var{connection} @var{database}
Return a @utf{}-8 bytevector or string representing the filename
associated with @var{database} of @var{connection}.  The main database
file has the name @code{main}.  If there is no attached @var{database}
on the @var{connection}, or if @var{database} is a temporary or
in--memory database, then a @false{} is returned.
@end defun


@defun sqlite3-db-readonly @var{connection} @var{database}
@defunx sqlite3-db-readonly? @var{connection} @var{database}
Return @code{1} if the @var{database} of @var{connection} is read--only,
@code{0} if it is read/write, or @code{-1} if it is not the name of a
database on @var{connection}.
@end defun

@c page
@node plain connect auth
@subsection Controlling access to data


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-set-authorizer @var{connection} @var{callback}
Register an authorizer callback with a particular database
@var{connection}; if successful return @code{SQLITE_OK}, else return an
@code{SQLITE_} error code.

The authorizer callback is called while a statement is being compiled
and must return a value to authorize or deny specific operations.

@var{callback} must be @false{} or a a pointer object referencing a
callback produced by @func{make-sqlite3-authorizer-callback}; when
@false{}: the previously registered callback, if any, is unregistered
from the state of @var{connection}.
@end defun


@defun make-sqlite3-authorizer-callback @var{callback}
Wrap a user supplied Scheme function and return a pointer object
referencing a callback function suitable to be used as second argument
in calls to @func{sqlite3-set-authorizer}; the returned pointer must be
released with a call to @func{free-c-callback} from @library{vicare
ffi}.

@var{user-scheme-callback} must accept @math{5} arguments:

@enumerate
@item
An exact integer, in the range of the C language type @code{int},
representing an authorizer action code (@code{SQLITE_INSERT},
@code{SQLITE_READ}, @code{SQLITE_SELECT}, @dots{}).

@item
@false{} or a pointer object referencing a zero--terminated string in
@utf{}-8 format; see SQLite documentation for details.

@item
@false{} or a pointer object referencing a zero--terminated string in
@utf{}-8 format; see SQLite documentation for details.

@item
@false{} or a pointer object referencing a zero--terminated string in
@utf{}-8 format; the string should be the database name (for example
@code{main}).

@item
@false{} or a pointer object referencing a zero--terminated string in
@utf{}-8 format; see SQLite documentation for details.
@end enumerate

@var{user-scheme-callback} must return an exact integer, in the range of
the C language type @code{int}, representing an authorizer return code:
@code{SQLITE_OK}, @code{SQLITE_DENY}, @code{SQLITE_IGNORE}.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}.  @var{user-scheme-callback} should take care of
handling its own exceptions.

@item
When an exception is catched: it is discarded and the callback returns
@code{SQLITE_DENY}.
@end itemize
@end defun


@defun sqlite3-authorizer-action-code->symbol @var{code}
Convert an exact integer, in the range of the C language type
@code{int}, representing a SQLite authorizer action code to the
corresponding symbol.

@example
(sqlite3-authorizer-action-code->symbol SQLITE_TRANSACTION)
@result{} SQLITE_TRANSACTION ;;symbol
@end example
@end defun


@defun sqlite3-authorizer-return-code->symbol @var{code}
Convert an exact integer, in the range of the C language type
@code{int}, representing a SQLite authorizer callback return code to the
corresponding symbol.

@example
(sqlite3-authorizer-return-code->symbol SQLITE_DENY)
@result{} SQLITE_DENY ;;symbol
@end example
@end defun


The following meaningless example shows the mechanism of registering an
authorizer:

@example
#!r6rs
(import (vicare)
  (vicare databases sqlite3)
  (vicare databases sqlite3 constants)
  (vicare syntactic-extensions)
  (prefix (vicare ffi) ffi.))

(define-syntax with-connection
  (syntax-rules ()
    ((_ (?connect-var) . ?body)
     (let ((?connect-var (sqlite3-open ":memory:")))
       (unwind-protect
           (let () . ?body)
         (when (sqlite3? ?connect-var)
           (sqlite3-close ?connect-var)))))))

(define (authorizer action a b c d)
  (define-inline (cstr->str s)
    (and (not (pointer-null? s))
         (cstring->string s)))
  (printf "Authorizer code: ~a\n"
          (sqlite3-authorizer-action-code->symbol action))
  (printf "Authorizer info: ~a, ~a, ~a, ~a\n"
          (cstr->str a) (cstr->str b)
          (cstr->str c) (cstr->str d))
  SQLITE_OK)

(define sql-preparation
  "create table Stuff
     (A TEXT, B TEXT, C TEXT);
   insert into Stuff (A, B, C)
     values ('one', 'two', 'three');
   insert into Stuff (A, B, C)
     values ('four', 'five', 'six');")

(define sql-statement
  "select * from Stuff;")

(let ((auth-cb (make-sqlite3-authorizer-callback authorizer)))
  (unwind-protect
      (with-connection (conn)
        (sqlite3-exec conn sql-preparation)
        (sqlite3-set-authorizer conn auth-cb)
        (let-values (((code stmt end-offset)
                      (sqlite3-prepare-v2 conn sql-statement)))
          code))
    (ffi.free-c-callback auth-cb)))
@result{} SQLITE_OK
@print{} Authorizer code: SQLITE_SELECT
@print{} Authorizer info: #f, #f, #f, #f
@print{} Authorizer code: SQLITE_READ
@print{} Authorizer info: Stuff, A, main, #f
@print{} Authorizer code: SQLITE_READ
@print{} Authorizer info: Stuff, B, main, #f
@print{} Authorizer code: SQLITE_READ
@print{} Authorizer info: Stuff, C, main, #f
@end example

@c page
@node plain connect misc
@subsection Miscellaneous connection operations


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-db-release-memory @var{connection}
Attempt to free as much heap memory as possible from database
@var{connection}.  Return an exact integer representing the number of
bytes actually freed, which might be more or less than the amount
requested.
@end defun


@defun sqlite3-table-column-metadata @var{connection} @var{database-name} @var{table-name} @var{column-name}
Return metadata about a specific column of a specific database table
accessible using the database @var{connection}.  Return @math{6} values:

@enumerate
@item
If successful @code{SQLITE_OK}, in which case the other returned values
are as explained below; else a @code{SQLITE_} error code, in which case
all the other returned values are @false{}.

@item
A @utf{}-8 bytevector representing the declared data type name.

@item
A @utf{}-8 bytevector representing the collation sequence name.

@item
A boolean, true if a @code{NOT NULL} constraint exists.

@item
A boolean, true if the column is part of the primary key.

@item
A boolean, true if the column is @code{AUTOINCREMENT}.
@end enumerate

@var{database-name} must be @false{} or a string or @utf{}-8 bytevector
or a pointer object representing the database name; when @false{} all
the databases are searched.  The main database is called @code{main}.

@var{table-name} must be a string or @utf{}-8 bytevector or pointer
object representing the table name.

@var{column-name} must be a string or @utf{}-8 bytevector or pointer
object representing the column name.
@end defun

@c page
@node plain exec
@section Simple execution of @sql{} snippets


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-exec @var{connection} @var{sql-snippet}
@defunx sqlite3-exec @var{connection} @var{sql-snippet} @var{each-row-callback}
Execute the @var{sql-snippet} in the context of the database
@var{connection}; when given, the @var{each-row-callback} is called to
process the result.  Return two values; when successful return
@code{SQLITE_OK} and @false{}, else return an exact integer representing
an error code and a string representing the associated error message.

@var{sql-snippet} must be a string or @utf{}-8 bytevector representing a
snippet of @sql{} code.

@var{each-row-callback} must be a pointer object referencing a callback
produced by @func{make-sqlite3-exec-callback}; when not given, no
callback is used.
@end defun


@defun make-sqlite3-exec-callback @var{user-scheme-callback}
Wrap a user supplied Scheme function and return a pointer object
referencing a callback function suitable to be used as
@var{each-row-callback} in calls to @func{sqlite3-exec}; the returned
pointer must be released with a call to @func{free-c-callback} from
@library{vicare ffi}.

@var{user-scheme-callback} must accept @math{3} arguments:

@enumerate
@item
An exact integer representing the number of elements in the result.

@item
A vector of @false{} or @utf{}-8 bytevectors representing texts
resulting from the @sql{} command; its length equals the value of the
first argument.

@item
A vector of @false{} or @utf{}-8 bytevectors representing names
resulting from the @sql{} command; its length equals the value of the
first argument.
@end enumerate

@var{user-scheme-callback} must return a single value which is the
answer to the question ``stop the query?''; if the returned value is
true the call to @func{sqlite3-exec} returns immediately; if the
returned value is @false{} the execution of @sql{} code goes on.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}; when an exception is catched: it is discarded and the
callback returns @code{SQLITE_ABORT} to @cfunc{sqlite3_exec}.
@var{user-scheme-callback} should take care of handling its own
exceptions.

@item
Check that the number of elements in the result can be represented with
a fixnum; the maximum length of vectors in Vicare is the value returned
by @func{greatest-fixnum}.  If the number of elements cannot be
represented with a fixnum: the callback returns @code{SQLITE_ABORT} to
@cfunc{sqlite3_exec}.

@item
If @var{user-scheme-callback} returns true: the wrapping callback
returns @code{SQLITE_ABORT} to @cfunc{sqlite3_exec}, else it returns
@code{SQLITE_OK}.
@end itemize
@end defun


The following example shows how to use the @func{sqlite3-exec} function
with a simple callback that stores the results in global variables.

@example
#!r6rs
(import (vicare)
  (vicare databases sqlite3)
  (vicare databases sqlite3 constants)
  (prefix (vicare ffi) ffi.))

(define database-pathname "sqlite.proof.db")
(define connection
  (sqlite3-open database-pathname))

(define sql-snippet
  "create table accounts
     (id       INTEGER PRIMARY KEY,
      nickname TEXT,
      password TEXT);
   insert into accounts (nickname, password)
     values ('ichigo', 'abcde');
   insert into accounts (nickname, password)
     values ('rukia', '12345');
   insert into accounts (nickname, password)
     values ('chad', 'fist');
   select * from accounts;")

(define result-names #f)
(define result-texts '())

(define each-row-callback
  (make-sqlite3-exec-callback
   (lambda (number-of-rows texts names)
     (unless result-names
       (set! result-names
             (map utf8->string (vector->list names))))
     (set! result-texts
           (cons (map utf8->string (vector->list texts))
                 result-texts))
     #f)))

(let-values (((rv error-message)
              (sqlite3-exec connection sql-snippet
                            each-row-callback)))
  (if (= SQLITE_OK rv)
      (begin
        (printf "names: ~a\n" result-names)
        (printf "texts: ~a\n" (reverse result-texts)))
    (printf "error: ~a\n" error-message)))
@print{} names: ("id" "nickname" "password")
@print{} texts: (("1" "ichigo" "abcde")
           ("2" "rukia" "12345")
           ("3" "chad" "fist"))

(ffi.free-c-callback each-row-callback)
(sqlite3-close connection)
@end example

@c page
@node plain get table
@section Simple retrieval of table from @sql{} snippets


The following @api{} is deprecated by SQLite, but kept for backwards
compatibility.  The following bindings are exported by the
@library{vicare databases sqlite3} library.


@defun sqlite3-get-table @var{connection} @var{sql-snippet}
Executa a @var{sql-snippet}, which must be a string or @utf{}-8
bytevector, in the context of @var{connection}; if successful return
@math{5} values:

@enumerate
@item
@code{SQLITE_OK} as fixnum.

@item
The @false{} object.

@item
An exact integer representing the number of rows in the result.

@item
An exact integer representing the number of columns in the result.

@item
A pointer object referencing the result structure which must be later
released by @func{sqlite3-free-table}.
@end enumerate

@noindent
else return @math{5} values:

@enumerate
@item
An @code{SQLITE_} error code as fixnum.

@item
A @utf{}-8 bytevector representing the error message.

@item
The fixnum zero representing the number of rows in the result.

@item
The fixnum zero representing the number of columns in the result.

@item
The @false{} object.
@end enumerate
@end defun


@defun sqlite3-free-table @var{table-pointer}
Properly release the result structure referenced by @var{table-pointer},
which must be a return value from @func{sqlite3-get-table}.
@end defun


@defun sqlite3-table-to-vector @var{num-of-rows} @var{num-of-cols} @var{table-pointer}
Convert the results of @func{sqlite3-get-table} to a Scheme vector;
always return a Scheme vector.

@var{num-of-rows} and @var{num-of-cols} must be exact non--negative
integers representing the number of rows and columns in the table.
@var{table-pointer} must be a pointer object referencing the table.

The returned value is a vector of vectors of @utf{}-8 bytevectors
representing the table; when a value is not available: rather than a
bytevector, @false{} is used.
@end defun


Here is an example of usage:

@example
#!r6rs
(import (vicare)
  (vicare databases sqlite3)
  (vicare databases sqlite3 constants)
  (vicare syntactic-extensions))

(define-syntax with-connection
  (syntax-rules ()
    ((_ (?connect-var) . ?body)
     (let ((pathname "sqlite.test.db"))
       (unwind-protect
           (let ((?connect-var (sqlite3-open pathname)))
             (unwind-protect
                 (begin . ?body)
               (when (sqlite3? ?connect-var)
                 (sqlite3-close ?connect-var))))
         (when (file-exists? pathname)
           (delete-file pathname)))))))

(with-connection (conn)
  (let ((sql "create table accounts
                (id       INTEGER PRIMARY KEY,
                 nickname TEXT,
                 password TEXT);
              insert into accounts (nickname, password)
                values ('ichigo', 'abcde');
              insert into accounts (nickname, password)
                values ('rukia', '12345');
              insert into accounts (nickname, password)
                values ('chad', 'fist');
              select * from accounts;"))
    (let-values (((rv errmsg num-of-rows num-of-cols result)
                  (sqlite3-get-table conn sql)))
      (unwind-protect
          (map (lambda (row)
                 (if (vector? row)
                     (map utf8->string (vector->list row))
                   row))
            (vector->list
             (sqlite3-table-to-vector num-of-rows
                                      num-of-cols
                                      result)))
        (sqlite3-free-table result)))))
@result{} (("id" "nickname" "password")
    ("1" "ichigo" "abcde")
    ("2" "rukia" "12345")
    ("3" "chad" "fist"))
@end example

@c page
@node plain statements
@section Prepared @sql{} statements


@cindex Prepared @sql{} statements
@cindex Precompiled @sql{} statements
@cindex @sql{} statements, prepared
@cindex @sql{} statements, precompiled


@menu
* plain statements example::    Precompiled @sql{} statement example.
* plain statements struct::     Precompiled @sql{} statements data
                                structure.
* plain statements prepare::    Precompiled @sql{} preparation and
                                finalisation.
* plain statements parameters:: Binding statement parameters values.
* plain statements exec::       Executing @sql{} prepared statements.
* plain statements result::     Inspecting the resulting row of @sql{}
                                prepared statements.
* plain statements aux::        Precompiled @sql{} auxiliary functions.
@end menu

@c page
@node plain statements example
@subsection Precompiled @sql{} statement example


The following example shows how to insert some data into a database and
then extract it using a prepared statement:

@example
#!r6rs
(import (vicare)
  (vicare databases sqlite3)
  (vicare databases sqlite3 constants)
  (vicare syntactic-extensions))

(set-port-buffer-mode! (current-output-port)
                       (buffer-mode line))

(define database-pathname ":memory:")

(define sql-preparation
  "create table accounts
     (id       INTEGER PRIMARY KEY,
      nickname TEXT,
      password TEXT);
   insert into accounts (nickname, password)
     values ('ichigo', 'abcde');
   insert into accounts (nickname, password)
     values ('rukia', '12345');
   insert into accounts (nickname, password)
     values ('chad', 'fist');")

(define sql-query
  "select * from accounts;")

(let ((conn (sqlite3-open database-pathname)))
  (when (sqlite3?/open conn)
    (let-values (((rv error-message)
                  (sqlite3-exec conn sql-preparation)))
      (when (= rv SQLITE_OK)
        (let-values (((code stmt end-offset)
                      (sqlite3-prepare-v2 conn sql-query)))
          (when (= code SQLITE_OK)
            (unwind-protect
                (do ((rv (sqlite3-step stmt) (sqlite3-step stmt))
                     (row 0 (+ 1 row)))
                    ((or (= rv SQLITE_DONE)
                         (not (= rv SQLITE_ROW))))
                  (let ((colnum (sqlite3-data-count stmt)))
                    (printf "row ~a: ~a, ~a\n" row
                       (sqlite3-column-text/string stmt 1)
                       (sqlite3-column-text/string stmt 2))))
              (sqlite3-finalize stmt))))))
    (sqlite3-close conn)))
@print{} row 0: ichigo, abcde
@print{} row 1: rukia, 12345
@print{} row 2: chad, fist
@end example

@c page
@node plain statements struct
@subsection Precompiled @sql{} statements structure


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@deftp {Struct Type} sqlite3-stmt
@cindex @var{statement} argument
@cindex Argument @var{statement}
An opaque Scheme structure holding a reference to an instance of the C
language type @code{sqlite3_stmt}; it references a prepared @sql{}
statement in the context of a SQLite database connection.
@vicareref{iklib structs, Structures and type descriptors}

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{statement}.

When instances of this type are garbage collected: the function
@func{sqlite3-finalize} is automatically applied to them.

Instances of this structure reference the connection to which they are
associated, in terms of instances of @code{sqlite3}: such connection
structures are not garbage collected until all the associated instances
of @code{sqlite3-stmt} are finalised, notice that the opposite is
@strong{not} true.
@end deftp


@defun sqlite3-stmt? @var{obj}
Return @true{} if @var{obj} is an instance of @code{sqlite3-stmt}.  This
predicate does @strong{not} check if the referenced statement has been
already finalised.
@end defun


@defun sqlite3-stmt?/valid @var{obj}
Return @true{} if @var{obj} is an instance of @code{sqlite3-stmt} and
the referenced prepared statement has not been finalised.
@end defun


@defun sqlite3-stmt-destructor @var{statement}
@defunx set-sqlite3-stmt-destructor! @var{statement} @var{func}
Retrieve or set a destructor function associated to the @var{statement}.

Whenever the @var{statement} is closed, either explicitly with
@func{sqlite3-finalize} or implicitly by the garbage collector,
@var{func} is applied to @var{statement} before the internal state of
@var{statement} is finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{statement};  If we do:

@example
(define stmt ...)
(set-sqlite3-stmt-destructor! connection
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((stmt)
       (destroy state))
      ((stmt dummy)
       state))))

(let ((state ((sqlite3-stmt-destructor stmt #t) stmt)))
  (do-something-with stmt state))
@end example

@noindent
we can easily associate values to @var{statement}.
@end defun

@c page
@node plain statements prepare
@subsection Precompiled @sql{} preparation and finalisation


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-finalize @var{statement}
Finalise a prepared statement; return a @code{SQLITE_} error code.
@var{statement} must be an instance of @code{sqlite3-stmt}.

The pointer object referencing the statement is reset to @cnull{}, if it
is not @cnull{} already, the reference to the associated connection
object is also canceled.  If is safe to call this function multiple
times for the same instance of @code{sqlite3-stmt}.
@end defun


@defun sqlite3-next-stmt @var{connection}
@defunx sqlite3-next-stmt @var{connection} @var{statement}
Return @false{} or a @code{sqlite3-stmt} instance representing the
``next'' prepared statement in the database @var{connection}; if the
return value is @false{}: no next statement is present.

When @var{statement} is not given or it is @false{}: the returned value
represents the ``first'' statement.
@end defun


@defun sqlite3-prepare-v2 @var{connection} @var{sql-snippet}
@defunx sqlite3-prepare-v2 @var{connection} @var{sql-snippet} @var{sql-offset}
@defunx sqlite3-prepare-v2 @var{connection} @var{sql-snippet} @var{sql-offset} @var{store-sql-text?}
Prepare a precompiled @sql{} statement in the context of a database
@var{connection}; if successful return @math{3} values:

@enumerate
@item
The constant @code{SQLITE_OK}.

@item
An instance of @code{sqlite3-stmt} referencing the statement.

@item
An offset in the @utf{}-8 bytevector representation of @var{sql-snippet}
representing the first @strong{unused} byte of @sql{} code.
@end enumerate

@noindent
if an error occurs return @math{3} values: a @code{SQLITE_} error code,
@false{}, @var{sql-offset}.

@var{sql-snippet} must be a string or @utf{}-8 bytevector holding the
@sql{} code from which to draw the statement.

The optional @var{sql-offset} must be an offset into the @utf{}-8
bytevector representation of @var{sql-snippet} specifying the start of
the @sql{} statement; when not given: it defaults to @code{0}.

The optional @var{store-sql-text?}  is interpreted as boolean: if true,
the portion of @var{sql-snippet} used to prepare the statement is saved
in the state of the returned @code{sqlite3-stmt}; when not given: it
defaults to @true{}.
@end defun


@defun sqlite3-prepare16-v2 @var{connection} @var{sql-snippet}
@defunx sqlite3-prepare16-v2 @var{connection} @var{sql-snippet} @var{sql-offset}
@defunx sqlite3-prepare16-v2 @var{connection} @var{sql-snippet} @var{sql-offset} @var{store-sql-text?}
Like @func{sqlite3-prepare-v2}, but handle bytevectors encoded in
@utf{}-16.

@quotation
@strong{NOTE} It appears that SQLite's idea of zero--terminated
@utf{}-16 array means that the array must end with @math{2} zero bytes.
So to obtain a suitable @utf{}-16 bytevector pathname from a string we
should do:

@example
(bytevector-append (string->utf16n sql-snippet)
                   '#vu8(0 0))
@end example

This is exactly what this function does when @var{sql-snippet} is a
string.
@end quotation
@end defun


@defun sqlite3-prepare @var{connection} @var{sql-snippet}
@defunx sqlite3-prepare @var{connection} @var{sql-snippet} @var{sql-offset}
@defunx sqlite3-prepare @var{connection} @var{sql-snippet} @var{sql-offset} @var{store-sql-text?}
The use of this function is discouraged, if possible use
@func{sqlite3-prepare-v2}.  The interface of this function is the same
of @func{sqlite-prepare-v2}, but the internals are different.
@end defun


@defun sqlite3-prepare16 @var{connection} @var{sql-snippet}
@defunx sqlite3-prepare16 @var{connection} @var{sql-snippet} @var{sql-offset}
@defunx sqlite3-prepare16 @var{connection} @var{sql-snippet} @var{sql-offset} @var{store-sql-text?}
The use of this function is discouraged, if possible use
@func{sqlite3-prepare16-v2}.  The interface of this function is the same
of @func{sqlite-prepare16-v2}, but the internals are different.
@end defun

@c page
@node plain statements parameters
@subsection Binding statement parameters values


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-bind-blob @var{statement} @var{parameter-index} @var{blob.data} @var{blob.start} @var{blob.length} @var{blob.destructor}
Bind a @var{statement} parameter to the supplied blob; if successful
return @code{SQLITE_OK}, else return a @code{SQLITE_} error code.

@var{parameter-index} must be a fixnum selecting a parameter in the
statement; the leftmost @sql{} parameter has an index of @code{1}.

@var{blob.data} must represent the blob's data: it can be a bytevector
or a pointer object.

@var{blob.start} must be a fixnum representing the offset in the blob
data of the first byte to be used as parameter value.

@var{blob.length} must be a fixnum representing the number of bytes from
the start in the blob data to be used as parameter value.

@var{blob.destructor} must be a pointer object referencing a destructor
function for the blob; special values are @code{SQLITE_STATIC} and
@code{SQLITE_TRANSIENT}.  If @var{blob.data} is a bytevector:
@var{blob.destructor} must be @code{SQLITE_TRANSIENT}.
@end defun


@defun sqlite3-bind-zeroblob @var{statement} @var{parameter-index} @var{blob-length}
Bind a @var{statement} parameter to a blob of null bytes of length
@var{blob-length}; if successful return @code{SQLITE_OK}, else return a
@code{SQLITE_} error code.

@var{parameter-index} must be a fixnum selecting a parameter in the
statement; the leftmost @sql{} parameter has an index of @code{1}.
@end defun

@c ------------------------------------------------------------

@defun sqlite3-bind-double @var{statement} @var{parameter-index} @var{value}
Bind a @var{statement} parameter to the supplied flonum @var{value}; if
successful return @code{SQLITE_OK}, else return a @code{SQLITE_} error
code.

@var{parameter-index} must be a fixnum selecting a parameter in the
statement; the leftmost @sql{} parameter has an index of @code{1}.
@end defun

@c ------------------------------------------------------------

@defun sqlite3-bind-int @var{statement} @var{parameter-index} @var{value}
Bind a @var{statement} parameter to the supplied exact integer
@var{value}, which must be in the range of a C language @code{int}; if
successful return @code{SQLITE_OK}, else return a @code{SQLITE_} error
code.

@var{parameter-index} must be a fixnum selecting a parameter in the
statement; the leftmost @sql{} parameter has an index of @code{1}.
@end defun

@c ------------------------------------------------------------

@defun sqlite3-bind-int64 @var{statement} @var{parameter-index} @var{value}
Bind a @var{statement} parameter to the supplied exact integer
@var{value}, which must be in the range of a C language
@code{sqlite3_int64}; if successful return @code{SQLITE_OK}, else return
a @code{SQLITE_} error code.

@var{parameter-index} must be a fixnum selecting a parameter in the
statement; the leftmost @sql{} parameter has an index of @code{1}.
@end defun

@c ------------------------------------------------------------

@defun sqlite3-bind-null @var{statement} @var{parameter-index}
Bind a @var{statement} parameter to null; if successful return
@code{SQLITE_OK}, else return a @code{SQLITE_} error code.

@var{parameter-index} must be a fixnum selecting a parameter in the
statement; the leftmost @sql{} parameter has an index of @code{1}.
@end defun

@c ------------------------------------------------------------

@defun sqlite3-bind-text @var{statement} @var{parameter-index} @var{text.data} @var{text.start} @var{text.length} @var{text.destructor}
@defunx sqlite3-bind-text16 @var{statement} @var{parameter-index} @var{text.data} @var{text.start} @var{text.length} @var{text.destructor}
Bind a @var{statement} parameter to the supplied text value; if
successful return @code{SQLITE_OK}, else return a @code{SQLITE_} error
code.

@var{parameter-index} must be a fixnum selecting a parameter in the
statement; the leftmost @sql{} parameter has an index of @code{1}.

@var{text.data} must represent the text's data: it can be a pointer
object, a string or a bytevector.  @func{sqlite-bind-text} accepts text
in @utf{}-8 encoding; @func{sqlite-bind-text16} accepts text in
@utf{}-16 encoding and native byte order.

@quotation
@strong{NOTE} It appears that SQLite's idea of zero--terminated
@utf{}-16 array means that the array must end with @math{2} zero bytes.
So to obtain a suitable @utf{}-16 bytevector from a string we should do:

@example
(bytevector-append (string->utf16n text.data)
                   '#vu8(0 0))
@end example

This is exactly what @func{sqlite3-bind-text16} does when
@var{text.data} is a string.
@end quotation

@var{text.start} must be a fixnum representing the offset in the text
data of the first byte to be used as parameter value; when
@var{text.data} is a string the offset is relative to the @utf{}-8 or
@utf{}-16 bytevector representation.  When @var{text.start} is @false{}:
@var{text.data} must be a bytevector or string, in this case the value
is changed to zero.

@var{text.length} must be @false{} or a fixnum representing the number
of bytes from the start in the text data to be used as parameter value;
when @var{text.data} is a string the offset is relative to the @utf{}-8
or @utf{}-16 bytevector representation.  When @var{text.length} is
@false{}: @var{text.data} must be a bytevector or string, in this case
the value is changed to the length of the given bytevector or bytevector
representation of the given string.

@var{text.destructor} must be a pointer object referencing a destructor
function for the text; special values are @code{SQLITE_STATIC} and
@code{SQLITE_TRANSIENT}.  If @var{text.data} is a bytevector or string:
@var{text.destructor} must be @code{SQLITE_TRANSIENT}.
@end defun

@c ------------------------------------------------------------

@defun sqlite3-bind-value @var{statement} @var{parameter-index} @var{value}
Bind a @var{statement} parameter to @var{value} which must be an
instance of @code{sqlite3-value} referencing an instance of the C
language type @code{sqlite3_value}; if successful return
@code{SQLITE_OK}, else return a @code{SQLITE_} error code.

@var{parameter-index} must be a fixnum selecting a parameter in the
statement; the leftmost @sql{} parameter has an index of @code{1}.
@end defun

@c ------------------------------------------------------------

@defun sqlite3-bind-parameter-count @var{statement}
Return an exact integer representing the number of @sql{} parameters in
a prepared @var{statement}; if successful return @code{SQLITE_OK}, else
return a @code{SQLITE_} error code.
@end defun


@defun sqlite3-bind-parameter-name @var{statement} @var{parameter-index}
Return a string representing the name of a @sql{} parameter in a
prepared @var{statement}; if successful return @code{SQLITE_OK}, else
return a @code{SQLITE_} error code.

@var{parameter-index} must be a fixnum selecting a parameter in the
statement; the leftmost @sql{} parameter has an index of @code{1}.
@end defun


@defun sqlite3-bind-parameter-index @var{statement} @var{parameter-name}
Return an exact integer representing the index of a @sql{} parameter in
a prepared @var{statement}; if successful return @code{SQLITE_OK}, else
return a @code{SQLITE_} error code.

@var{parameter-name} must be a string or @utf{}-8 bytevector
representing the name of the parameter; @sql{} parameter indexes start
from @code{1}.
@end defun


@defun sqlite3-clear-bindings @var{statement}
Use this routine to reset all host parameters to NULL; if successful
return @code{SQLITE_OK}, else return a @code{SQLITE_} error code.
@end defun

@c page
@node plain statements exec
@subsection Executing @sql{} prepared statements


@cindex Executing prepared @sql{} statements
@cindex Executing precompiled @sql{} statements
@cindex Step execution of prepared @sql{} statements
@cindex @sql{} statements, executing
@cindex @sql{} statements, running
@cindex @sql{} statements, stepping


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-step @var{statement}
Evaluate the @var{statement}, step by step; in general, this function
must be applied multiple times to the same @var{statement} to fully
evaluate a it.  If successful the return value is:

@table @code
@item SQLITE_DONE
The execution is finished.

@item SQLITE_ROW
A row of resulting data is available.
@end table

@noindent
else an error occurred and the return value is a @code{SQLITE_} error
code.
@end defun


@defun sqlite3-reset @var{statement}
Reset a prepared @var{statement} object back to its initial state, ready
to be reexecuted; if successful return @code{SQLITE_OK}, else return a
@code{SQLITE_} error code.

Any @sql{} statement parameters that had values bound to them retain
their values; use @func{sqlite3-clear-bindings} to reset the bindings.
@end defun

@c page
@node plain statements result
@subsection Inspecting the resulting row of @sql{} prepared statements


@cindex Result of prepared @sql{} statements
@cindex Result of precompiled @sql{} statements
@cindex @sql{} statements, inspecting resulting row


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-column-count @var{statement}
Return an exact integer representing the number of columns in the result
set returned by the prepared @var{statement}.
@end defun

@c ------------------------------------------------------------

@defun sqlite3-column-name @var{statement} @var{column-index}
@defunx sqlite3-column-name/string @var{statement} @var{column-index}
Return a bytevector or string representing the name of the column at
@var{column-index} in the resulting row; expect the name to be encoded
in @utf{}-8.  When successful return the bytevector or string, else
return @false{}.

@var{column-index} is the index of the selected column; column indexes
are zero--based.
@end defun


@defun sqlite3-column-name16 @var{statement} @var{column-index}
@defunx sqlite3-column-name16/string @var{statement} @var{column-index}
Return a bytevector or string representing the name of the column at
@var{column-index} in the resulting row; expect the name to be encoded
in @utf{}-16 with native byte order.  When successful return the
bytevector or string, else return @false{}.

@var{column-index} is the index of the selected column; column indexes
are zero--based.
@end defun

@c ------------------------------------------------------------

@defun sqlite3-column-database-name @var{statement} @var{column-index}
@defunx sqlite3-column-database-name/string @var{statement} @var{column-index}
Return a bytevector or string representing the database name that is the
origin of the column at @var{column-index} in the resulting row; expect
the name to be encoded in @utf{}-8.  When successful return the
bytevector or string, else return @false{}.

@var{column-index} is the index of the selected column; column indexes
are zero--based.
@end defun


@defun sqlite3-column-database-name16 @var{statement} @var{column-index}
@defunx sqlite3-column-database-name16/string @var{statement} @var{column-index}
Return a bytevector or string representing the database name that is the
origin of the column at @var{column-index} in the resulting row; expect
the name to be encoded in @utf{}-16 with native byte order.  When
successful return the bytevector or string, else return @false{}.

@var{column-index} is the index of the selected column; column indexes
are zero--based.
@end defun

@c ------------------------------------------------------------

@defun sqlite3-column-table-name @var{statement} @var{column-index}
@defunx sqlite3-column-table-name/string @var{statement} @var{column-index}
Return a bytevector or string representing the table name that is the
origin of the column at @var{column-index} in the resulting row; expect
the name to be encoded in @utf{}-8.  When successful return the
bytevector or string, else return @false{}.

@var{column-index} is the index of the selected column; column indexes
are zero--based.
@end defun


@defun sqlite3-column-table-name16 @var{statement} @var{column-index}
@defunx sqlite3-column-table-name16/string @var{statement} @var{column-index}
Return a bytevector or string representing the table name that is the
origin of the column at @var{column-index} in the resulting row; expect
the name to be encoded in @utf{}-16 with native byte order.  When
successful return the bytevector or string, else return @false{}.

@var{column-index} is the index of the selected column; column indexes
are zero--based.
@end defun

@c ------------------------------------------------------------

@defun sqlite3-column-origin-name @var{statement} @var{column-index}
@defunx sqlite3-column-origin-name/string @var{statement} @var{column-index}
Return a bytevector or string representing the column name that is the
origin of the column at @var{column-index} in the resulting row; expect
the name to be encoded in @utf{}-8.  When successful return the
bytevector or string, else return @false{}.

@var{column-index} is the index of the selected column; column indexes
are zero--based.
@end defun


@defun sqlite3-column-origin-name16 @var{statement} @var{column-index}
@defunx sqlite3-column-origin-name16/string @var{statement} @var{column-index}
Return a bytevector or string representing the column name that is the
origin of the column at @var{column-index} in the resulting row; expect
the name to be encoded in @utf{}-16 with native byte order.  When
successful return the bytevector or string, else return @false{}.

@var{column-index} is the index of the selected column; column indexes
are zero--based.
@end defun

@c ------------------------------------------------------------

@defun sqlite3-column-decltype @var{statement} @var{column-index}
@defunx sqlite3-column-decltype/string @var{statement} @var{column-index}
Return a bytevector or string representing the declared type name of the
column at @var{column-index} in the resulting row; expect the name to be
encoded in @utf{}-8.  When successful return the bytevector or string,
else return @false{}.

@var{column-index} is the index of the selected column; column indexes
are zero--based.
@end defun


@defun sqlite3-column-decltype16 @var{statement} @var{column-index}
@defunx sqlite3-column-decltype16/string @var{statement} @var{column-index}
Return a bytevector or string representing the declared type name of the
column at @var{column-index} in the resulting row; expect the name to be
encoded in @utf{}-16 with native byte order.  When successful return the
bytevector or string, else return @false{}.

@var{column-index} is the index of the selected column; column indexes
are zero--based.
@end defun

@c ------------------------------------------------------------

@defun sqlite3-data-count @var{statement}
Return an exact integer representing the number of columns in the
current row of the result set of prepared @var{statement}.
@end defun


@defun sqlite3-column-type @var{statement} @var{column-index}
Return an exact integer representing the datatype code for the initial
data type of the result column at @var{column-index}.  The returned
value is one of: @code{SQLITE_INTEGER}, @code{SQLITE_FLOAT},
@code{SQLITE_TEXT}, @code{SQLITE_BLOB}, @code{SQLITE_NULL}.

@var{column-index} is the index of the selected column; column indexes
are zero--based.
@end defun

@c ------------------------------------------------------------

@defun sqlite3-column-blob @var{statement} @var{column-index}
Return @false{} or a bytevector holding the blob in the result column;
The number of bytes in the blob is determined with a call to
@cfunc{sqlite3_column_bytes}.  If the blob is of zero length: the return
value is @false{}.

@var{column-index} is the index of the selected column; column indexes
are zero--based.
@end defun


@defun sqlite3-column-bytes @var{statement} @var{column-index}
Return an exact integer representing the number of bytes in the blob or
@utf{}-8 string in the result column.

@var{column-index} is the index of the selected column; column indexes
are zero--based.
@end defun


@defun sqlite3-column-bytes16 @var{statement} @var{column-index}
Return an exact integer representing the number of bytes in the blob or
@utf{}-16 string, native byte order, in the result column.

@var{column-index} is the index of the selected column; column indexes
are zero--based.
@end defun


@defun sqlite3-column-double @var{statement} @var{column-index}
Return a flonum representing the value in the result column.

@var{column-index} is the index of the selected column; column indexes
are zero--based.
@end defun


@defun sqlite3-column-int @var{statement} @var{column-index}
Return an exact integer, in the range of the C language type @code{int},
representing the value in the result column.

@var{column-index} is the index of the selected column; column indexes
are zero--based.
@end defun


@defun sqlite3-column-int64 @var{statement} @var{column-index}
Return an exact integer, in the range of the C language type
@code{sqlite3_int64}, representing the value in the result column.

@var{column-index} is the index of the selected column; column indexes
are zero--based.
@end defun

@c ------------------------------------------------------------

@defun sqlite3-column-text @var{statement} @var{column-index}
@defunx sqlite3-column-text/string @var{statement} @var{column-index}
Return @false{} or a string or @utf{}-8 bytevector holding the text in
the result column; the number of bytes in the text is determined with a
call to @cfunc{sqlite3_column_bytes}.

@var{column-index} is the index of the selected column; column indexes
are zero--based.
@end defun


@defun sqlite3-column-text16 @var{statement} @var{column-index}
@defunx sqlite3-column-text16/string @var{statement} @var{column-index}
Return @false{} or a string or @utf{}-16 bytevector, in native byte
order, holding the text in the result column; the number of bytes in the
text is determined with a call to @cfunc{sqlite3_column_bytes16}.

@var{column-index} is the index of the selected column; column indexes
are zero--based.
@end defun

@c ------------------------------------------------------------

@defun sqlite3-column-value @var{statement} @var{column-index}
Return an instance of @code{sqlite3-value} referencing the value in the
result column as a reference to an unprotected @code{sqlite3_value}
object.

@var{column-index} is the index of the selected column; column indexes
are zero--based.
@end defun

@c page
@node plain statements aux
@subsection Precompiled @sql{} auxiliary functions


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-sql @var{statement}
@defunx sqlite3-sql/string @var{statement}
Retrieve a saved copy of the original @sql{} text used to create a
prepared statement if that statement was compiled using either
@func{sqlite3-prepare-v2} or @func{sqlite3-prepare16-v2} and return it
as @utf{}-8 bytevector or string.
@end defun


@defun sqlite3-stmt-readonly @var{statement}
@defunx sqlite3-stmt-readonly? @var{statement}
Return @true{} if and only if the prepared @var{statement} makes no
direct changes to the content of the database file, else return
@false{}.
@end defun


@defun sqlite3-stmt-busy @var{statement}
@defunx sqlite3-stmt-busy? @var{statement}
Return @true{} if the prepared @var{statement} has been stepped at least
once using @func{sqlite3-step} but has not run to completion and/or has
not been reset using @func{sqlite3-reset}.
@end defun


@defun sqlite3-db-handle @var{statement}
Return the instance of @code{sqlite3} to which a prepared
@var{statement} belongs.
@end defun

@c page
@node plain blobs
@section @blob{}s for incremental input/output


This @api{} accesses the data area of a @blob{} in chunks, rather than
as a whole memory block; this allows SQLite not to load in memory the
whole contents of a @blob{}, making some operations more efficient.  The
following bindings are exported by the @library{vicare databases
sqlite3} library.


@deftp {Struct Type} sqlite3-blob
@cindex @var{blob} argument
@cindex Argument @var{blob}
A Scheme structure holding a reference to an instance of the C language
type @code{sqlite3_blob}, it references a @blob{} used for incremental
input/output.  @vicareref{iklib structs, Structures and type
descriptors}

It has the following public fields:

@table @code
@item connection
The instance of @code{sqlite3} to which this @blob{} is associated.

@item database
A string representing the name of the database in which this @blob{} is
contained.

@item table
A string representing the name of the table in which this @blob{} is
contained.

@item column
A string representing the name of the column in which this @blob{} is
contained.

@item rowid
An exact integer representing the id of the row in which this @blob{} is
contained.

@item write-enabled?
A boolean, @true{} if this @blob{} can be written to.
@end table

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{blob}.

When instances of this type are garbage collected:
@func{sqlite3-blob-close} is automatically applied to them.
@end deftp


@defun sqlite3-blob? @var{obj}
Return @true{} if @var{obj} is an instance of @code{sqlite3-blob}.
@end defun


@defun sqlite3-blob?/open @var{obj}
Return @true{} if @var{obj} is an instance of @code{sqlite3-blob} and
the @blob{} it represents is open.
@end defun


@defun sqlite3-blob-connection @var{blob}
@defunx sqlite3-blob-database @var{blob}
@defunx sqlite3-blob-table @var{blob}
@defunx sqlite3-blob-column @var{blob}
@defunx sqlite3-blob-rowid @var{blob}
@defunx sqlite3-blob-write-enabled? @var{blob}
Accessors for the fields of @code{sqlite3-blob} instances.
@end defun


@defun sqlite3-blob-open @var{connection} @var{database-name} @var{table-name} @var{column-name} @var{rowid} @var{write-enabled?}
Open a handle to the @blob{} located in row @var{rowid}, column
@var{column-name}, table @var{table-name} in database
@var{database-name}.  If successful return @math{2} values:
@code{SQLITE_OK} and an instance of @code{sqlite3-blob}; else return
@math{2} values: a @code{SQLITE_} error code and @false{}.

@var{database-name} must be a string or @utf{}-8 bytevector or pointer
object to a zero--terminated C string representing the database name.
The main database is called @code{main}.

@var{table-name} must be a string or @utf{}-8 bytevector or pointer
object to a zero--terminated C string representing the table name.

@var{column-name} must be a string or @utf{}-8 bytevector or pointer
object to a zero--terminated C string representing the column name.

@var{rowid} must be an exact integer in the range of the C language type
@code{sqlite3_int64} representing the row id.

If @var{write-enabled?} is true: the returned @blob{} is opened for
reading and writing; if it is @false{}: the returned @blob{} is opened
for reading only.
@end defun


@defun sqlite3-blob-reopen @var{blob} @var{rowid}
Move an existing blob handle so that it points to a different row of the
same database table.  If successful return @code{SQLITE_OK} else return
a @code{SQLITE_} error code.

@var{rowid} must be an exact integer in the range of the C language type
@code{sqlite3_int64} representing the row id.
@end defun


@defun sqlite3-blob-close @var{blob}
Close the @var{BLOB}.  If successful return @code{SQLITE_OK}, else
return a @code{SQLITE_} error code.

It is safe to apply multiple times this function to the same @var{blob}:
the first time the @blob{} is closed, the subsequent times nothing
happens and the return value is @code{SQLITE_OK}.
@end defun


@defun sqlite3-blob-bytes @var{blob}
Return an exact integer representing the size in bytes of the
@var{blob}.
@end defun


@defun sqlite3-blob-read @var{src-blob} @var{src-offset} @var{dst-buffer} @var{dst-offset} @var{number-of-bytes}
Read data from an open @var{src-blob} handle into a caller--supplied
buffer.  If successful return @code{SQLITE_OK}, else return a
@code{SQLITE_} error code.

@var{src-offset} must be an exact integer, in the range of the C
language type @code{int}, representing the offset into @var{src-blob}'s
data area of the first byte to be read.

@var{dst-buffer} must be a bytevector or pointer object representing the
destination buffer.

@var{dst-offset} must be an exact integer representing the offset into
@var{dst-buffer} of the first byte to be written.  When @var{dst-buffer}
is a pointer object: @var{dst-offset} must be in the range of the C
language type @code{int}; when @var{dst-buffer} is a bytevector:
@var{dst-offset} must be a fixnum.

@var{number-of-bytes} must be an exact integer in the range of the C
language type @code{int} representing the number of bytes to copy.
@end defun


@defun sqlite3-blob-write @var{dst-blob} @var{dst-offset} @var{src-buffer} @var{src-offset} @var{number-of-bytes}
Write data into an open @var{dst-blob} handle from a caller--supplied
buffer.  If successful return @code{SQLITE_OK}, else return a
@code{SQLITE_} error code.

@var{dst-offset} must be an exact integer, in the range of the C
language type @code{int}, representing the offset into @var{dst-blob}'s
data area of the first byte to be written.

@var{src-buffer} must be a bytevector or pointer object representing the
source buffer.

@var{src-offset} must be an exact integer representing the offset into
@var{src-buffer} of the first byte to be read.  When @var{src-buffer} is
a pointer object: @var{src-offset} must be in the range of the C
language type @code{int}; when @var{src-buffer} is a bytevector:
@var{src-offset} must be a fixnum.

@var{number-of-bytes} must be an exact integer in the range of the C
language type @code{int} representing the number of bytes to copy.
@end defun


The following is a meaningless example usage of the @blob{} incremental
input/output @api{}; we skip some error checking:

@example
#!vicare
(import (vicare)
  (vicare databases sqlite3)
  (vicare databases sqlite3 constants)
  (vicare syntactic-extensions))

(define-syntax with-connection
  (syntax-rules ()
    ((_ (?connect-var) . ?body)
     (let ((pathname "sqlite.test.db"))
       (unwind-protect
           (let ((?connect-var (sqlite3-open pathname)))
             (unwind-protect
                 (begin . ?body)
               (when (sqlite3? ?connect-var)
                 (sqlite3-close ?connect-var))))
         (when (file-exists? pathname)
           (delete-file pathname)))))))

(with-connection (conn)
  (sqlite3-exec conn "create table stuff \
     (id INTEGER PRIMARY KEY, data TEXT);")
  (let-values
       (((code stmt end-offset1)
         (sqlite3-prepare-v2 conn
            "insert into stuff (id, data) \
               values (?1, ?2);")))
    (unwind-protect
        (begin
          (sqlite3-bind-int64    stmt 1 1)
          (sqlite3-bind-zeroblob stmt 2 4)
          (sqlite3-step stmt))
      (when (sqlite3-stmt?/valid stmt)
        (sqlite3-finalize stmt))))
  (let-values
      (((rv blob)
        (sqlite3-blob-open conn "main" "stuff" "data" 1 #t)))
    (unwind-protect
        (begin
          (sqlite3-blob-write blob 0 '#ve(ascii "ciao") 0 4)
          (let ((buffer (make-bytevector 4)))
            (sqlite3-blob-read blob 0 buffer 0 4)
            (printf "~a\n" (utf8->string buffer))))
      (sqlite3-blob-close blob))))
@print{} "ciao"
@end example

@c page
@node plain sql aux
@section @sql{} execution auxiliary functions


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-last-insert-rowid @var{connection}
Return the row id of the most recent successful @code{INSERT} into the
database.
@end defun


@defun sqlite3-changes @var{connection}
Return the number of database rows that were changed or inserted or
deleted by the most recently completed @sql{} statement on the
@var{connection}.
@end defun


@defun sqlite3-total-changes @var{connection}
Return the number of row changes caused by @code{INSERT}, @code{UPDATE}
or @code{DELETE} statements since the database @var{connection} was
opened.
@end defun


@defun sqlite3-interrupt @var{connection}
Cause any pending database operation to abort and return at its earliest
opportunity.  Return unspecified values.
@end defun


@defun sqlite3-complete @var{sql-snippet}
@defunx sqlite3-complete16 @var{sql-snippet}
Determine if the @sql{} code in @var{sql-snippet} seems to form a
complete @sql{} statement or if additional input is needed before
sending the text into SQLite for parsing; return @true{} or @false{}.

When calling @func{sqlite3-complete}: @var{sql-snippet} must be a string
or @utf{}-8 bytevector.

When calling @func{sqlite3-complete16}: @var{sql-snippet} must be a
string or @utf{}-16 bytevector in native byte order.

@quotation
@strong{NOTE} It appears that SQLite's idea of zero--terminated
@utf{}-16 array means that the array must end with @math{2} zero bytes.
So to obtain a suitable @utf{}-16 bytevector from a string we should do:

@example
(bytevector-append (string->utf16n sql-snippet)
                   '#vu8(0 0))
@end example

This is exactly what @func{sqlite3-complete16} does when
@var{sql-snippet} is a string.
@end quotation
@end defun


@defun sqlite3-progress-handler @var{connection}
@defunx sqlite3-progress-handler @var{connection} @var{instruction-count} @var{callback}
Cause the @var{callback} function to be invoked periodically during long
running calls to @func{sqlite3-exec}, @func{sqlite3-step} and
@func{sqlite3-get-table}; return unspecified values.

@var{instruction-count} must be an exact integer, in the range of the C
language type @code{int}, representing the number of virtual machine
instructions that are evaluated between successive invocations of the
callback; when not given: it defaults to zero.

@var{callback} must be a pointer object referencing a callback produced
by @func{make-sqlite3-progress-handler-callback}; when not given, no
callback is used and the previously set callback is removed.
@end defun


@defun make-sqlite3-progress-handler-callback @var{user-scheme-callback}
Wrap a user supplied Scheme function and return a pointer object
referencing a callback function suitable to be used as @var{callback} in
calls to @func{sqlite3-progress-handler}; the returned pointer must be
released with a call to @func{free-c-callback} from @library{vicare
ffi}.

@var{user-scheme-callback} must accept no argument.

@var{user-scheme-callback} must return a single value which is the
answer to the question ``interrupt the operation?''; if the returned
value is true the caller interrupts the operations as soon as possible;
if the returned value is @false{} the execution of @sql{} code goes on.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}; when an exception is catched: it is discarded and the
callback returns @code{0}.  @var{user-scheme-callback} should take care
of handling its own exceptions.

@item
If @var{user-scheme-callback} returns true: the wrapping callback
returns @code{1} to the caller, else it returns @code{0}.
@end itemize
@end defun

@c page
@node plain hooks
@section Notification hooks


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-commit-hook @var{connection} @var{callback}
Register a callback function to be invoked whenever a transaction is
committed.  Any callback set by a previous call to this function for the
same database connection is overridden.

@var{callback} must be @false{} or a pointer object referencing a
callback produced by @func{make-sqlite3-commit-hook-callback}; if
@var{callback} is @false{}: the previous callback is registration is
removed.
@end defun


@defun make-sqlite3-commit-hook-callback @var{user-scheme-function}
Wrap a user supplied Scheme function and return a pointer object
referencing a callback function suitable to be used as @var{callback} in
calls to @func{sqlite3-commit-hook}; the returned pointer must be
released with a call to @func{free-c-callback} from @library{vicare
ffi}.

@var{user-scheme-callback} must accept no arguments and must return a
single value which is the answer to the question ``rollback the
commit?''; if the returned value is true the commit is converted into a
rollback; if the returned value is @false{} the commit completes.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}; when an exception is catched: it is discarded and the
callback returns @code{0} allowing the commit to complete.
@var{user-scheme-callback} should take care of handling its own
exceptions.

@item
If @var{user-scheme-callback} returns true: the wrapping callback
returns @code{1}, else it returns @code{0}.
@end itemize
@end defun

@c ------------------------------------------------------------

@defun sqlite3-rollback-hook @var{connection} @var{callback}
Register a callback function to be invoked whenever a transaction is
rolled back.  Any callback set by a previous call to this function for
the same database connection is overridden.

@var{callback} must be @false{} or a pointer object referencing a
callback produced by @func{make-sqlite3-rollback-hook-callback}; if
@var{callback} is @false{}: the previous callback is registration is
removed.
@end defun


@defun make-sqlite3-rollback-hook-callback @var{user-scheme-function}
Wrap a user supplied Scheme function and return a pointer object
referencing a callback function suitable to be used as @var{callback} in
calls to @func{sqlite3-rollback-hook}; the returned pointer must be
released with a call to @func{free-c-callback} from @library{vicare
ffi}.

@var{user-scheme-callback} must accept no arguments and can return
unspecified values.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}; when an exception is catched: it is discarded and the
callback returns no values.  @var{user-scheme-callback} should take care
of handling its own exceptions.
@end itemize
@end defun

@c ------------------------------------------------------------

@defun sqlite3-update-hook @var{connection} @var{callback}
Register a callback function with the database @var{connection} to be
invoked whenever a row is updated, inserted or deleted.  Any callback
set by a previous call to this function for the same database connection
is overridden.

@var{callback} must be @false{} or a pointer object referencing a
callback produced by @func{make-sqlite3-update-hook-callback}; if
@var{callback} is @false{}: the previous callback is registration is
removed.
@end defun


@defun make-sqlite3-update-hook-callback @var{user-scheme-function}
Wrap a user supplied Scheme function and return a pointer object
referencing a callback function suitable to be used as @var{callback} in
calls to @func{sqlite3-update-hook}; the returned pointer must be
released with a call to @func{free-c-callback} from @library{vicare
ffi}.

@var{user-scheme-callback} must accept the following arguments:

@enumerate
@item
One of the constants: @code{SQLITE_INSERT}, @code{SQLITE_DELETE},
@code{SQLITE_UPDATE}, depending on the operation that caused the
callback to be invoked.

@item
A pointer object referencing a zero--terminated @utf{}-8 memory block
holding the database name; we can use @func{cstring->bytevector} to
convert it to a @utf{}-8 bytevector and @func{cstring->string} to
convert it into a Scheme string.

@item
A pointer object referencing a zero--terminated @utf{}-8 memory block
holding the table name containing the affected row; we can use
@func{cstring->bytevector} to convert it to a @utf{}-8 bytevector and
@func{cstring->string} to convert it into a Scheme string.

@item
The rowid of the row; in the case of an update, this is the rowid after
the update takes place.
@end enumerate

@var{user-scheme-callback} can return unspecified values.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}; when an exception is catched: it is discarded and the
callback returns no values.  @var{user-scheme-callback} should take care
of handling its own exceptions.
@end itemize
@end defun

@c page
@node plain errors
@section Error codes and error messages


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-errcode @var{connection}
@defunx sqlite3-extended-errcode @var{connection}
Return an exact integer representing the numeric result code or extended
result code for the most recent failed @code{sqlite3_} @api{} call
associated with a database @var{connection}.
@end defun


@defun sqlite3-errmsg @var{connection}
@defunx sqlite3-errmsg16 @var{connection}
Return an English--language string that describes the error for the most
recent failed @code{sqlite3_} @api{} call associated with a database
@var{connection}, as either @utf{}-8 or @utf{}-16 respectively.
@end defun

@c page
@node plain extensions
@section Loading SQLite extensions


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-enable-load-extension @var{onoff}
When @var{onoff} is true: turn the SQLite extensions mechanism on; else
turn it off; extension loading is off by default.  If successful return
@code{SQLITE_OK}, else return a @code{SQLITE_} error code.
@end defun


@defun sqlite3-load-extension @var{connection} @var{pathname}
@defunx sqlite3-load-extension @var{connection} @var{pathname} @var{procname}
Load an SQLite extension library from the named file in the context of
@var{connection}.  If successful return @math{2} values:
@code{SQLITE_OK} and @false{}; else return @math{2} values: a
@code{SQLITE_} error code and a string representing an error message.

@var{pathname} must be a string or @utf{}-8 bytevector or pointer object
representing the file pathname.

@var{procname} must be @false{} or a string or @utf{}-8 bytevector or
pointer object representing the entry point function name of the
extension; when not given or @false{}: the entry point defaults to
@code{sqlite3_extension_init}.
@end defun


@defun sqlite3-auto-extension @var{entry-point}
Causes the @var{entry-point} to be invoked for each new database
connection that is created.  The idea here is that @var{entry-point} is
the entry point for a statically linked SQLite extension that is to be
automatically loaded into all new database connections.  If successful
return @code{SQLITE_OK}, else return a @code{SQLITE_} error code.

@var{entry-point} must be a pointer object referencing an appropriate
callback function.
@end defun


@defun sqlite3-reset-auto-extension
Disable all automatic extensions previously registered using
@func{sqlite3-auto-extension}.  Return unspecified values.
@end defun

@c page
@node plain functions
@section Extending @sql{} with custom functions


SQLite allows us to create new @sql{} scalar functions and aggregate
functions:

@itemize
@item
A @sql{} scalar function processes single values from a row of input
data and produces a single return value.

@item
A @sql{} aggregate function processes values from a sequence of rows,
row by row, and finally produces a single return value.  An aggregate
function is somewhat like @func{fold-left}.
@end itemize

@menu
* plain functions examples::    Examples of new @sql{} functions.
* plain functions creation::    Creating new @sql{} functions.
* plain functions arguments::   Converting @sql{} arguments to Scheme.
* plain functions retvals::     Converting Scheme return values to @sql{}.
* plain functions aux::         Auxiliary @sql{} functions operations.
@end menu

@c page
@node plain functions examples
@subsection Examples of new @sql{} functions


@menu
* plain functions examples sin:: The trigonometric sine function.
* plain functions examples sum:: The column sum aggregate.
* plain functions examples max:: The column max aggregate.
* plain functions examples rex:: Matching with regular expressions.
* plain functions examples sub:: Nested statements execution.
@end menu

@c page
@node plain functions examples sin
@subsubsection The trigonometric sine function


The following example shows how to implement and use the @sql{} scalar
function @func{mysine} on top of the Scheme function @func{sin}:

@example
#!r6rs
(import (vicare)
  (vicare databases sqlite3)
  (vicare databases sqlite3 constants)
  (vicare syntactic-extensions)
  (prefix (vicare ffi) ffi.))

(define-syntax with-connection
  (syntax-rules ()
    ((_ (?connect-var) . ?body)
     (let ((?connect-var (sqlite3-open ":memory:")))
       (unwind-protect
           (let () . ?body)
         (when (sqlite3? ?connect-var)
           (sqlite3-close ?connect-var)))))))

(define (mysine-cb context args)
  (let* ((x (vector-ref args 0))
         (T (sqlite3-value-numeric-type x)))
    (if (or (= T SQLITE_INTEGER)
            (= T SQLITE_FLOAT))
        (let* ((x (sqlite3-value-double x))
               (y (sin x)))
          (sqlite3-result-double context y))
      (begin
        (sqlite3-result-error-code context SQLITE_ERROR)
        (sqlite3-result-error context
          "expected numeric argument for mysine function")))))

(define (mysine-cb context args)
  (define (%error message)
    (sqlite3-result-error-code context SQLITE_ERROR)
    (sqlite3-result-error context message))
  (guard (E (else
             (%error (if (message-condition? E)
                         (condition-message E)
                       "internal error while executing \
                        mysine function"))))
    (let* ((x (vector-ref args 0))
           (T (sqlite3-value-numeric-type x)))
      (if (or (= T SQLITE_INTEGER)
              (= T SQLITE_FLOAT))
          (let* ((x (sqlite3-value-double x))
                 (y (sin x)))
            (sqlite3-result-double context y))
        (%error "expected numeric argument for \
                 mysine function")))))

(define (exec-cb number-of-cols texts names)
  (let ((names (map utf8->string (vector->list names)))
        (texts (map string->number
                 (map utf8->string
                   (vector->list texts)))))
    (printf "~a: ~a\n" (car names) (car texts))
    #f))

(define sql-snippet-1
  "create table stuff (x TEXT);
   insert into stuff (x) values ('1.0');
   insert into stuff (x) values ('1.1');
   insert into stuff (x) values ('1.2');
   select mysine(x) as 'Sine' from stuff;")

(define sql-snippet-2
  "create table stuff2 (x TEXT);
   insert into stuff2 (x) values ('ciao');
   select mysine(x) as 'Sine' from stuff2;")

(define (exec-snippet conn cb snippet)
  (let-values
      (((rv errmsg)
        (sqlite3-exec conn snippet cb)))
    (unless (= rv SQLITE_OK)
      (printf "~a: ~a\n"
              (sqlite3-error-code->symbol rv)
              errmsg))))

(let ((mysine-cb (make-sqlite3-function      mysine-cb))
      (exec-cb   (make-sqlite3-exec-callback exec-cb)))
  (unwind-protect
      (with-connection (conn)
        (sqlite3-create-function conn "mysine" 1
            SQLITE_ANY #f mysine-cb #f #f)
        (exec-snippet conn exec-cb sql-snippet-1)
        (exec-snippet conn exec-cb sql-snippet-2))
    (ffi.free-c-callback mysine-cb)
    (ffi.free-c-callback exec-cb)))
@print{} Sine: 0.841470984807897
@print{} Sine: 0.891207360061435
@print{} Sine: 0.932039085967226
@print{} SQLITE_ERROR: expected numeric argument for mysine function
@end example

@c page
@node plain functions examples sum
@subsubsection The column sum aggregate


The following example shows how to implement and use the @sql{}
aggregate function @func{mysum}, which sums values from a column of
flonums; notice how the aggregate stores the accumulated sum in a block
of raw memory allocated with @func{sqlite3-aggregate-context} and such
block is reset to zero by SQLite, which is fine as starting value for a
sum function:

@example
#!r6rs
(import (vicare)
  (vicare databases sqlite3)
  (vicare databases sqlite3 constants)
  (vicare syntactic-extensions)
  (prefix (vicare ffi) ffi.)
  (prefix (vicare words) words.))

(define-syntax with-connection
  (syntax-rules ()
    ((_ (?connect-var) . ?body)
     (let ((?connect-var (sqlite3-open ":memory:")))
       (unwind-protect
           (let () . ?body)
         (when (sqlite3? ?connect-var)
           (sqlite3-close ?connect-var)))))))

(define (mysum.data context)
  (sqlite3-aggregate-context context words.SIZEOF_DOUBLE))

(define (mysum.accumulated-sum-ref data.ptr)
  (pointer-ref-c-double data.ptr 0))

(define (mysum.accumulated-sum-set! data.ptr sum)
  (pointer-set-c-double! data.ptr 0 sum))

(define (mysum.step context args)
  (define (%error message)
    (sqlite3-result-error-code context SQLITE_ERROR)
    (sqlite3-result-error context message))
  (guard (E (else
             (%error (if (message-condition? E)
                         (condition-message E)
                       "internal error while executing \
                        mysum function"))))
    (let* ((P (mysum.data context))
           (x (vector-ref args 0))
           (T (sqlite3-value-numeric-type x)))
      (if (or (= T SQLITE_INTEGER)
              (= T SQLITE_FLOAT))
          (let* ((S (mysum.accumulated-sum-ref P))
                 (A (vector-ref args 0))
                 (X (sqlite3-value-double A))
                 (S (+ X S)))
            (mysum.accumulated-sum-set! P S))
        (mysum.accumulated-sum-set! P +nan.0)))))

(define (mysum.final context)
  (define (%error message)
    (sqlite3-result-error-code context SQLITE_ERROR)
    (sqlite3-result-error context message))
  (guard (E (else
             (%error (if (message-condition? E)
                         (condition-message E)
                       "internal error while executing \
                        mysum function"))))
    (let* ((P (mysum.data context))
           (S (mysum.accumulated-sum-ref P)))
      (if (nan? S)
          (%error "expected numeric argument for \
                   mysum function")
        (sqlite3-result-double context S)))))

(define (exec-cb number-of-cols texts names)
  (printf "~a: ~a\n"
     (utf8->string (vector-ref names 0))
     (string->number (utf8->string (vector-ref texts 0))))
  #f)

(define (exec-snippet conn cb snippet)
  (let-values
      (((rv errmsg)
        (sqlite3-exec conn snippet cb)))
    (unless (= rv SQLITE_OK)
      (printf "~a: ~a\n"
              (sqlite3-error-code->symbol rv)
              errmsg))))

(define sql-snippet-1
  "create table stuff (x TEXT);
   insert into stuff (x) values ('1.0');
   insert into stuff (x) values ('1.1');
   insert into stuff (x) values ('1.2');
   select mysum(x) as 'Sum' from stuff;")

(define sql-snippet-2
  "create table stuff2 (x TEXT);
   insert into stuff2 (x) values ('ciao');
   select mysum(x) as 'Sum' from stuff2;")

(let ((mysum.step  (make-sqlite3-aggregate-step  mysum.step))
      (mysum.final (make-sqlite3-aggregate-final mysum.final))
      (exec-cb     (make-sqlite3-exec-callback   exec-cb)))
  (unwind-protect
      (with-connection (conn)
        (sqlite3-create-function conn "mysum" 1 SQLITE_ANY #f
                                 #f mysum.step mysum.final)
        (exec-snippet conn exec-cb sql-snippet-1)
        (exec-snippet conn exec-cb sql-snippet-2))
    (ffi.free-c-callback mysum.step)
    (ffi.free-c-callback mysum.final)
    (ffi.free-c-callback exec-cb)))
@print{} Sum: 3.3
@print{} SQLITE_ERROR: expected numeric argument for mysum function
@end example

@c page
@node plain functions examples max
@subsubsection The column max aggregate


The following example shows how to implement and use the @sql{}
aggregate function @func{mymax}, which selects the maximum value from a
column of flonums; notice that the aggregate stores the current maximum
in a block of raw memory allocated with @func{sqlite3-aggregate-context}
along with an initialisation flag:

@example
#!r6rs
(import (vicare)
  (vicare databases sqlite3)
  (vicare databases sqlite3 constants)
  (vicare syntactic-extensions)
  (prefix (vicare ffi) ffi.)
  (prefix (vicare words) words.))

(define-syntax with-connection
  (syntax-rules ()
    ((_ (?connect-var) . ?body)
     (let ((?connect-var (sqlite3-open ":memory:")))
       (unwind-protect
           (let () . ?body)
         (when (sqlite3? ?connect-var)
           (sqlite3-close ?connect-var)))))))

(define mymax.context-size
  (+ words.SIZEOF_LONG words.SIZEOF_DOUBLE))

(define (mymax.context-pointer context)
  (sqlite3-aggregate-context context mymax.context-size))

(define-inline (mymax.initialised! pointer)
  (pointer-set-c-unsigned-long! pointer 0 1))

(define-inline (mymax.initialised? pointer)
  (not (zero? (pointer-ref-c-unsigned-long pointer 0))))

(define-inline (mymax.max-set! pointer flonum)
  (pointer-set-c-double! pointer words.SIZEOF_LONG flonum))

(define-inline (mymax.max-ref pointer)
  (pointer-ref-c-double  pointer words.SIZEOF_LONG))

(define (mymax.step context args)
  (define (%error message)
    (sqlite3-result-error-code context SQLITE_ERROR)
    (sqlite3-result-error context message))
  (guard (E (else
             (%error (if (message-condition? E)
                         (condition-message E)
                       "internal error while executing \
                        mysum function"))))
    (let* ((P (mymax.context-pointer context))
           (A (vector-ref args 0))
           (T (sqlite3-value-numeric-type A)))
      (if (or (= T SQLITE_INTEGER)
              (= T SQLITE_FLOAT))
          (let ((X (sqlite3-value-double A))
                (M (mymax.max-ref P)))
            (if (mymax.initialised? P)
                (unless (nan? M)
                  (mymax.max-set! P (max X M)))
              (begin
                (mymax.initialised! P)
                (mymax.max-set! P X))))
        (begin
          (unless (mymax.initialised? P)
            (mymax.initialised! P))
          (mymax.max-set! P +nan.0))))))

(define (mymax.final context)
  (define (%error message)
    (sqlite3-result-error-code context SQLITE_ERROR)
    (sqlite3-result-error context message))
  (guard (E (else
             (%error (if (message-condition? E)
                         (condition-message E)
                       "internal error while executing \
                        mysum function"))))
    (let ((P (mymax.context-pointer context)))
      (if (mymax.initialised? P)
          (let ((M (mymax.max-ref P)))
            (if (nan? M)
                (%error "expected numeric argument for \
                         mymax function")
              (sqlite3-result-double context M)))
        -inf.0))))

(define (exec-cb number-of-cols texts names)
  (printf "~a: ~a\n"
          (utf8->string (vector-ref names 0))
          (let ((S (utf8->string (vector-ref texts 0))))
            (cond ((string->number S)
                   => (lambda (x) x))
                  ((string=? S "+Inf")
                   +inf.0)
                  ((string=? S "-Inf")
                   -inf.0)
                  (else +nan.0))))
  #f)

(define (exec-snippet conn cb snippet)
  (let-values
      (((rv errmsg)
        (sqlite3-exec conn snippet cb)))
    (unless (= rv SQLITE_OK)
      (printf "~a: ~a\n"
              (sqlite3-error-code->symbol rv)
              errmsg))))

(define sql-snippet-1
  "create table stuff (x TEXT);
   insert into stuff (x) values ('1.0');
   insert into stuff (x) values ('3.0');
   insert into stuff (x) values ('2.0');
   select mymax(x) as 'Max' from stuff;")

(define sql-snippet-2
  "create table stuff2 (x TEXT);
   insert into stuff2 (x) values ('ciao');
   select mymax(x) as 'Max' from stuff2;")

(let ((mymax.step  (make-sqlite3-aggregate-step  mymax.step))
      (mymax.final (make-sqlite3-aggregate-final mymax.final))
      (exec-cb     (make-sqlite3-exec-callback   exec-cb)))
  (unwind-protect
      (with-connection (conn)
        (sqlite3-create-function conn "mymax" 1 SQLITE_ANY #f
                                 #f mymax.step mymax.final)
        (exec-snippet conn exec-cb sql-snippet-1)
        (exec-snippet conn exec-cb sql-snippet-2))
    (ffi.free-c-callback mymax.step)
    (ffi.free-c-callback mymax.final)
    (ffi.free-c-callback exec-cb)))
@print{} Max: 3.0
@print{} SQLITE_ERROR: expected numeric argument for mymax function
@end example

@c page
@node plain functions examples rex
@subsubsection Matching with regular expressions


The following example shows how to implement and use the @sql{} scalar
function @func{regexp}, which matches a string against a regular
expression; notice the use of value metadata to cache the compiled
version of the regular expression pattern.  This example makes use of
the library @library{vicare glibc}.

@example
#!r6rs
(import (vicare)
  (vicare databases sqlite3)
  (vicare databases sqlite3 constants)
  (vicare syntactic-extensions)
  (prefix (vicare ffi) ffi.)
  (prefix (vicare glibc) glibc.)
  (vicare platform-constants))

(define-syntax with-connection
  (syntax-rules ()
    ((_ (?connect-var) . ?body)
     (let ((?connect-var (sqlite3-open ":memory:")))
       (unwind-protect
           (let () . ?body)
         (when (sqlite3? ?connect-var)
           (sqlite3-close ?connect-var)))))))

(define (regexp context args)
  (define (%compile-rex context rex)
    (let ((cre (glibc.regcomp/disown rex REG_EXTENDED)))
      (sqlite3-set-auxdata context 0 cre
        (make-sqlite3-auxdata-destructor %rex-destructor))
      cre))
  (define (%rex-destructor rex)
    (glibc.regfree rex))
  (let* ((rex (sqlite3-value-text/string (vector-ref args 0)))
         (str (sqlite3-value-text/string (vector-ref args 1)))
         (cre (or (sqlite3-get-auxdata context 0)
                  (%compile-rex context rex))))
    (sqlite3-result-int context
                        (if (glibc.regexec cre str 0)
                            1
                          0))))

(define (exec-cb number-of-cols texts names)
  (printf "~a: ~a\n"
          (utf8->string (vector-ref names 0))
          (utf8->string (vector-ref texts 0)))
  #f)

(define sql-snippet
  "create table Strings (x TEXT);
   insert into Strings (x) values ('ciao');
   insert into Strings (x) values ('123');
   insert into Strings (x) values ('hello');
   insert into Strings (x) values ('456');
   select x as 'Match' from Strings
     where regexp('[a-z]+', x) = 1;")

(let ((regexp  (make-sqlite3-function      regexp))
      (exec-cb (make-sqlite3-exec-callback exec-cb)))
  (unwind-protect
      (with-connection (conn)
        (sqlite3-create-function conn "regexp" 2
                                 SQLITE_ANY #f
                                 regexp #f #f)
        (let-values
            (((rv errmsg)
              (sqlite3-exec conn sql-snippet exec-cb)))
          rv))
    (ffi.free-c-callback regexp)
    (ffi.free-c-callback exec-cb)))
@result{} SQLITE_OK
@print{} Match: ciao
@print{} Match: hello
@end example

Here is another example of @code{regexp} usage in which the regular
expression patterns are taken from a table; the preamble and functions
are the same as before, only the @sql{} code is different:

@example
(define sql-snippet-2
  "create table Rexes (x TEXT);
   insert into Rexes (x) values ('[a-z]+');
   insert into Rexes (x) values ('[0-9]+');
   create table Strings (y TEXT);
   insert into Strings (y) values ('ciao');
   insert into Strings (y) values ('123');
   insert into Strings (y) values ('!!!');
   insert into Strings (y) values ('hello');
   insert into Strings (y) values (',,,');
   insert into Strings (y) values ('456');
   select y as 'Match' from Strings
     inner join Rexes on regexp(Rexes.x, Strings.y) = 1;")

(let ((regexp  (make-sqlite3-function      regexp))
      (exec-cb (make-sqlite3-exec-callback exec-cb)))
  (unwind-protect
      (with-connection (conn)
        (sqlite3-create-function conn "regexp" 2
                                 SQLITE_ANY #f
                                 regexp #f #f)
        (let-values
            (((rv errmsg)
              (sqlite3-exec conn sql-snippet-2 exec-cb)))
          rv))
    (ffi.free-c-callback regexp)
    (ffi.free-c-callback exec-cb)))
@result{} SQLITE_OK
@print{} Match: ciao
@print{} Match: 123
@print{} Match: hello
@print{} Match: 456
@end example

Here is another example of @code{regexp} usage in which this application
defined function is invoked by the @sql{} @code{REGEXP} operator; the
preamble and functions are the same as before, only the @sql{} code is
different:

@example
(define sql-snippet-3
  "create table Strings (x TEXT);
   insert into Strings (x) values ('ciao');
   insert into Strings (x) values ('123');
   insert into Strings (x) values ('hello');
   insert into Strings (x) values ('456');
   select x as 'Match' from Strings
     where x REGEXP '[a-z]+';")

(let ((regexp  (make-sqlite3-function      regexp))
      (exec-cb (make-sqlite3-exec-callback exec-cb)))
  (unwind-protect
      (with-connection (conn)
        (sqlite3-create-function conn "regexp" 2 SQLITE_ANY #f
                                 regexp #f #f)
        (let-values
            (((rv errmsg)
              (sqlite3-exec conn sql-snippet-3 exec-cb)))
          rv))
    (ffi.free-c-callback regexp)
    (ffi.free-c-callback exec-cb)))
@result{} SQLITE_OK
@print{} Match: ciao
@print{} Match: hello
@end example

@c page
@node plain functions examples sub
@subsubsection Nested statements execution


The following example shows how to executa a @sql{} statement from the
implementation function of an application--defined @sql{} function; the
@sql{} function retrieves a temporary connection object using
@func{sqlite3-context-db-handle}.

@example
#!r6rs
(import (vicare)
  (vicare databases sqlite3)
  (vicare databases sqlite3 constants)
  (vicare syntactic-extensions)
  (prefix (vicare ffi) ffi.))

(define-syntax with-connection
  (syntax-rules ()
    ((_ (?connect-var) . ?body)
     (let ((?connect-var (sqlite3-open ":memory:")))
       (unwind-protect
           (let () . ?body)
         (when (sqlite3? ?connect-var)
           (sqlite3-close ?connect-var)))))))

(module (getfirst)

  (define (getfirst context args)
    (define-inline (%return-error)
      (sqlite3-result-null context))
    (let ((surname (%get-argument context args)))
      (if surname
          (let ((stmt (%make-stmt context)))
            (if stmt
                (unwind-protect
                    (let ((name (%exec-stmt stmt surname)))
                      (if name
                          (sqlite3-result-text context name
                             0 #f SQLITE_TRANSIENT)
                        (%return-error)))
                  (sqlite3-finalize stmt))
              (%return-error)))
        (%return-error))))

  (define (%exec-stmt stmt surname)
    (sqlite3-bind-text stmt 1 surname
       #f #f SQLITE_TRANSIENT)
    (let ((rv (sqlite3-step stmt)))
      (and (= rv SQLITE_ROW)
           (sqlite3-column-text/string stmt 0))))

  (define (%make-stmt context)
    (let ((conn (sqlite3-context-db-handle context))
          (sql  "select name from Names \
                   where Names.surname = ?;"))
      (let-values (((code stmt end-offset)
                    (sqlite3-prepare-v2 conn sql)))
        (and (= code SQLITE_OK) stmt))))

  (define (%get-argument context args)
    (let ((A (vector-ref args 0)))
      (if (= SQLITE_TEXT (sqlite3-value-type A))
          (sqlite3-value-text/string A)
        #f)))

  ) #| end of module |#

(define (exec-cb number-of-cols texts names)
  (printf "~a: ~a\n"
          (utf8->string (vector-ref names 0))
          (utf8->string (vector-ref texts 0)))
  #f)

(define sql-snippet
  "create table Surnames (surname TEXT);
   insert into Surnames (surname)
     values ('Alpha');
   insert into Surnames (surname)
     values ('Beta');
   insert into Surnames (surname)
     values ('Delta');
   create table Names (surname TEXT, name TEXT);
   insert into Names (surname, name)
     values ('Alpha', 'Gamma');
   insert into Names (surname, name)
     values ('Beta',  'Epsilon');
   insert into Names (surname, name)
     values ('Delta', 'Theta');
   select getfirst(surname) as 'Name'
     from Surnames;")

(let ((getfirst (make-sqlite3-function getfirst))
      (exec-cb  (make-sqlite3-exec-callback exec-cb)))
  (unwind-protect
      (with-connection (conn)
        (let ((rv (sqlite3-create-function conn "getfirst" 1
                     SQLITE_ANY #f getfirst #f #f)))
          (if (= rv SQLITE_OK)
              (let-values
                  (((rv errmsg)
                    (sqlite3-exec conn sql-snippet exec-cb)))
                (list rv errmsg))
            (list rv (sqlite3-errmsg conn)))))
    (ffi.free-c-callback getfirst)
    (ffi.free-c-callback exec-cb)))
@result{} SQLITE_OK
@print{} Name: Gamma
@print{} Name: Epsilon
@print{} Name: Theta
@end example

@c page
@node plain functions creation
@subsection Creating new @sql{} functions


The following functions are used to add @sql{} scalar functions or
aggregate functions or to redefine the behavior of existing @sql{}
scalar functions or aggregate functions.  The following bindings are
exported by the @library{vicare databases sqlite3} library.


@defun sqlite3-create-function @var{connection} @var{function-name} @var{arity} @var{text-encoding} @var{custom-data} @var{func} @var{step} @var{final}
Create a new @sql{} scalar or aggregate function, or override an
existing @sql{} scalar or aggregate function, in the context of
@var{connection}.  If successful return @code{SQLITE_OK}, else return a
@code{SQLITE_} error code.

@var{function-name} must be a string or @utf{}-8 bytevector representing
the name of the new @sql{} function; its length in bytes must not exceed
@math{255} bytes.

@var{arity} must be an exact integer representing the number of
arguments to the @sql{} function.

@var{text-encoding} must be an exact integer representing one of the
constants: @code{SQLITE_UTF8}, @code{SQLITE_UTF16LE},
@code{SQLITE_UTF16BE}, @code{SQLITE_UTF16}, @code{SQLITE_ANY},
@code{SQLITE_UTF16_ALIGNED}.  It specifies which text encoding this
@sql{} function prefers for its parameters; when no preference is
needed, we should use @code{SQLITE_ANY}.

@var{custom-data} must be @false{} or a pointer object; @false{} is
internally converted to a @cnull{} pointer.  When a pointer object: this
argument must reference custom data for the @sql{} function, which can
be retrieved with @func{sqlite3-user-data}.

@var{func} must be @false{} or a pointer object representing @cnull{} or
a pointer object referencing a callback function implementing a @sql{}
scalar function; when a non-@cnull{} pointer, it should be the return
value of a call to @func{make-sqlite3-function}.

@var{step} must be @false{} or a pointer object representing @cnull{} or
a pointer object referencing a callback function implementing the step
of a @sql{} aggregate function; when a non-@cnull{} pointer, it should
be the return value of a call to @func{make-sqlite3-aggregate-step}.

@var{final} must be @false{} or a pointer object representing @cnull{}
or a pointer object referencing a callback function implementing the
finalisation of a @sql{} aggregate function; when a non-@cnull{}
pointer, it should be the return value of a call to
@func{make-sqlite3-aggregate-final}.
@end defun


@defun sqlite3-create-function16 @var{connection} @var{function-name} @var{arity} @var{text-encoding} @var{custom-data} @var{func} @var{step} @var{final}
Like @func{sqlite3-create-function}, but expect @var{function-name} to
be a string or @utf{}-16 bytevector in native byte--order.
@end defun


@defun sqlite3-create-function-v2 @var{connection} @var{function-name} @var{arity} @var{text-encoding} @var{custom-data} @var{func} @var{step} @var{final} @var{destroy}
Like @func{sqlite3-create-function}, but accept the additional argument
@var{destroy}.

@var{destroy} must be @false{} or a pointer object representing @cnull{}
or referencing a callback function:

@itemize
@item
When @var{destroy} is @false{} or a pointer object representing
@cnull{}: the argument is ignored.

@item
When @var{destroy} is a non-@cnull{} pointer object: the referenced
callback is called when the custom @sql{} function is deleted or this
call to @func{sqlite3-create-function-v2} fails.

@var{destroy} accepts a single argument equal to @var{custom-data} and
it is meant to finalise the referenced data, if any.
@end itemize
@end defun

@c ------------------------------------------------------------

@defun make-sqlite3-function @var{user-scheme-function}
Wrap a user supplied Scheme function to produce a callback function
callable from C; return a pointer object referencing a callback function
suitable to be used as @var{func} argument in calls to
@func{sqlite3-create-function}; the returned pointer must be released
with a call to @func{free-c-callback} from @library{vicare ffi}.

@var{user-scheme-callback} must accept two arguments:

@enumerate
@item
An instance of @code{sqlite3-context} to be used to acquire the function
call arguments and to set the function call return value.  @ref{plain
functions retvals, sqlite3-context}

@item
A vector of instances of @code{sqlite3-value} referencing the arguments
to the @sql{} function call.  @ref{plain functions arguments,
sqlite3-value}
@end enumerate

@var{user-scheme-callback} can return unspecified values.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}.  @var{user-scheme-callback} should take care of
handling its own exceptions.

@item
When an exception is catched: the callback returns @code{(void)}.

@item
When an exception is catched: the error code @code{SQLITE_ERROR} is set
in the function call context with @func{sqlite3-result-error}.

@item
When an exception is catched: the error message from the raised
@condition{message} condition, if any, is set as error message in the
function call context with @func{sqlite3-result-error}; if no
@condition{message} condition is present, a generic error message is
used.
@end itemize

Notice that it is perfectly all right to share the value returned by
this function among multiple SQLite database connections implementing
the same @sql{} scalar function.
@end defun

@c ------------------------------------------------------------

@defun make-sqlite3-aggregate-step @var{user-scheme-function}
Wrap a user supplied Scheme function to produce a callback function
callable from C; return a pointer object referencing a callback function
suitable to be used as @var{step} argument in calls to
@func{sqlite3-create-function}; the returned pointer must be released
with a call to @func{free-c-callback} from @library{vicare ffi}.

@var{user-scheme-callback} must accept two arguments:

@enumerate
@item
An instance of @code{sqlite3-context} to be used to acquire the function
call arguments and to set the function call return value.  Notice that,
in the course of an aggregate function computation, we cannot rely on
the context being the same for every call to the aggregate
implementation functions.  @ref{plain functions retvals,
sqlite3-context}

@item
A vector of instances of @code{sqlite3-value} referencing the arguments
to the @sql{} function call.  @ref{plain functions arguments,
sqlite3-value}
@end enumerate

@var{user-scheme-callback} can return unspecified values.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}.  @var{user-scheme-callback} should take care of
handling its own exceptions.

@item
When an exception is catched: the callback returns @code{(void)}.

@item
When an exception is catched: the error code @code{SQLITE_ERROR} is set
in the function call context with @func{sqlite3-result-error}.

@item
When an exception is catched: the error message from the raised
@condition{message} condition, if any, is set as error message in the
function call context with @func{sqlite3-result-error}; if no
@condition{message} condition is present, a generic error message is
used.
@end itemize

Notice that it is perfectly all right to share the value returned by
this function among multiple SQLite database connections implementing
the same @sql{} aggregate function.
@end defun


@defun make-sqlite3-aggregate-final @var{user-scheme-function}
Wrap a user supplied Scheme function to produce a callback function
callable from C; return a pointer object referencing a callback function
suitable to be used as @var{final} argument in calls to
@func{sqlite3-create-function}; the returned pointer must be released
with a call to @func{free-c-callback} from @library{vicare ffi}.

@var{user-scheme-callback} must accept one argument:

@enumerate
@item
An instance of @code{sqlite3-context} to be used to acquire the function
call arguments and to set the function call return value.  Notice that,
in the course of an aggregate function computation, we cannot rely on
the context being the same for every call to the aggregate
implementation functions.  @ref{plain functions retvals,
sqlite3-context}
@end enumerate

@var{user-scheme-callback} can return unspecified values.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}.  @var{user-scheme-callback} should take care of
handling its own exceptions.

@item
When an exception is catched: the callback returns @code{(void)}.

@item
When an exception is catched: the error code @code{SQLITE_ERROR} is set
in the function call context with @func{sqlite3-result-error}.

@item
When an exception is catched: the error message from the raised
@condition{message} condition, if any, is set as error message in the
function call context with @func{sqlite3-result-error}; if no
@condition{message} condition is present, a generic error message is
used.
@end itemize

Notice that it is perfectly all right to share the value returned by
this function among multiple SQLite database connections implementing
the same @sql{} aggregate function.
@end defun

@c ------------------------------------------------------------

@defun make-sqlite3-function-destructor @var{user-scheme-function}
Wrap a user supplied Scheme function and return a pointer object
referencing a callback function suitable to be used as @var{destroy} in
calls to @func{sqlite3-create-function-v2}; the returned pointer must be
released with a call to @func{free-c-callback} from @library{vicare
ffi}.

@var{user-scheme-callback} must accept a single argument equal to
@var{custom-data} in the call to @func{sqlite3-create-function-v2}; such
argument can be @false{} or a pointer object.

@var{user-scheme-callback} can return unspecified values.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}; when an exception is catched: the callback returns
@code{(void)}.  @var{user-scheme-callback} should take care of handling
its own exceptions.
@end itemize
@end defun

@c ------------------------------------------------------------

@defun sqlite3-delete-function @var{connection} @var{function-name}
@defunx sqlite3-delete-function16 @var{connection} @var{function-name}
Remove a @sql{} function from the context of @var{connection}.  If
successful return @code{SQLITE_OK}, else return a @code{SQLITE_} error
code.

@var{function-name} must be a string or @utf{}-8 bytevector or @utf{}-16
bytevector representing the name of the new @sql{} function; its length
in bytes must not exceed @math{255} bytes.
@end defun

@c page
@node plain functions arguments
@subsection Converting @sql{} arguments to Scheme


The following functions are used by custom @sql{} scalar and aggregate
functions to convert @sql{} arguments to Scheme values.  For all the
following functions: @var{value} must be an instance of
@code{sqlite3-value}.  The following bindings are exported by the
@library{vicare databases sqlite3} library.


@deftp {Struct Type} sqlite3-value
Opaque structure type wrapping an instance of the C language type
@code{sqlite3_value}.  @vicareref{iklib structs, Structures and type
descriptors}

Instances of this type are valid only in the course of a @sql{} function
call, that is the dynamic extent of the Scheme functions @var{func},
@var{step} and @var{final} used as arguments to
@func{sqlite3-create-function}.  Outside this extent the referenced data
becomes invalid and must not be accessed.
@end deftp


@defun sqlite3-value? @var{obj}
Return @true{} if @var{obj} is an instance of @code{sqlite3-value}.
@end defun


@defun sqlite3-value-type @var{value}
Return an exact integer representing the data type of @var{value} as one
of the constants: @code{SQLITE_INTEGER}, @code{SQLITE_FLOAT},
@code{SQLITE_BLOB}, @code{SQLITE_NULL}, @code{SQLITE_TEXT}.
@end defun


@defun sqlite3-value-numeric-type @var{value}
Attempt to to convert @var{value} to an integer or floating point
number; if such a conversion is possible without loss of information
then the conversion is performed, otherwise no conversion occurs.
Return an exact integer representing the data type of @var{value}
@strong{after} the conversion, as one of the constants:
@code{SQLITE_INTEGER}, @code{SQLITE_FLOAT}, @code{SQLITE_BLOB},
@code{SQLITE_NULL}, @code{SQLITE_TEXT}.
@end defun


@defun sqlite3-value-blob @var{value}
Return a bytevector holding a @blob{} representation of @var{value}.
@end defun


@defun sqlite3-value-bytes @var{value}
Return an exact integer representing the number of bytes needed to hold
a @blob{} or @utf{}-8 text representation of @var{value}.
@end defun


@defun sqlite3-value-bytes16 @var{value}
Return an exact integer representing the number of bytes needed to hold
a @utf{}-16 text representation of @var{value}.
@end defun


@defun sqlite3-value-double @var{value}
Return a flonum representing @var{value}.  This conversion is possible
if @func{sqlite3-value-numeric-type} returns a numeric type when applied
to @var{value}.
@end defun


@defun sqlite3-value-int @var{value}
Return an exact integer, in the range of the C language type @code{int},
representing @var{value}.  This conversion is possible if
@func{sqlite3-value-numeric-type} returns a numeric type when applied to
@var{value}.
@end defun


@defun sqlite3-value-int64 @var{value}
Return an exact integer, in the range of the C language type
@code{sqlite3_int64}, representing @var{value}.  This conversion is
possible if @func{sqlite3-value-numeric-type} returns a numeric type
when applied to @var{value}.
@end defun


@defun sqlite3-value-text @var{value}
@defunx sqlite3-value-text/string @var{value}
Return a @utf{}-8 bytevector or string representing @var{value} as a
string.
@end defun


@defun sqlite3-value-text16 @var{value}
@defunx sqlite3-value-text16/string @var{value}
Return a @utf{}-16 bytevector, in native byte--order, or string
representing @var{value} as a string.
@end defun


@defun sqlite3-value-text16le @var{value}
@defunx sqlite3-value-text16le/string @var{value}
Return a @utf{}-16 bytevector, in little--endian byte--order, or string
representing @var{value} as a string.
@end defun


@defun sqlite3-value-text16be @var{value}
@defunx sqlite3-value-text16be/string @var{value}
Return a @utf{}-16 bytevector, in big--endian byte--order, or string
representing @var{value} as a string.
@end defun

@c page
@node plain functions retvals
@subsection Converting Scheme return values to @sql{}


The following functions are used by custom @sql{} scalar and aggregate
functions to convert Scheme return values to @sql{} values.  For all the
following functions: @var{context} must be an instance of
@code{sqlite3-context}.  The following bindings are exported by the
@library{vicare databases sqlite3} library.


@deftp {Struct Type} sqlite3-context
Opaque structure type wrapping an instance of the C language type
@code{sqlite3_context}.  @vicareref{iklib structs, Structures and type
descriptors}

Instances of this type are valid only in the course of a @sql{} function
call, that is the dynamic extent of the Scheme functions @var{func},
@var{step} and @var{final} used as arguments to
@func{sqlite3-create-function}.  Outside this extent the referenced data
becomes invalid and must not be accessed.
@end deftp


@defun sqlite3-context? @var{obj}
Return @true{} if @var{obj} is an instance of @code{sqlite3-context}.
@end defun

@c ------------------------------------------------------------

@subsubheading @blob{} return values


@defun sqlite3-result-blob @var{context} @var{blob.data} @var{blob.start} @var{blob.len} @var{destructor}
Set the result of a call to a custom @sql{} function to a @blob{};
return unspecified values.

The @blob{} is described by @var{blob.data}, @var{blob.start} and
@var{blob.len}.  @var{blob.start} must be a non--negative exact integer,
in the range of the C language type @code{int}, representing the offset
from the beginning of @var{blob.data} of the first byte to read.  The
arguments are interpreted as follows:

@itemize
@item
If @var{blob.data} is a bytevector and @var{blob.len} is @false{}: the
@blob{} is set to the bytevector data from @var{blob.start} to the end.

@item
If @var{blob.data} is a bytevector and @var{blob.len} is not @false{},
@var{blob.len} must be an exact integer in the range of the C language
type @code{int}: the @blob{} is set to the first @var{blob.len} bytes of
bytevector data starting at offset @var{blob.start}.

@item
If @var{blob.data} is a pointer object, @var{blob.len} must be an exact
integer in the range of the C language type @code{int}: the @blob{} is
set to the first @var{blob.len} bytes of the referenced memory block
starting at offset @var{blob.start}.
@end itemize

If @var{destructor} is @false{}: the destructor is set to
@code{SQLITE_TRANSIENT}; else @var{destructor} must be a pointer object
referencing the destructor function to be used to finalise the @blob{}.
@end defun


@defun sqlite3-result-zeroblob @var{context} @var{blob.len}
Set the result of a call to a custom @sql{} function to a zero @blob{}
holding @var{blob.len} bytes; return unspecified values.

@var{blob.len} must be a non--negative exact integer in the range of the
C language type @code{int}.
@end defun

@c ------------------------------------------------------------

@subsubheading Numeric return values


@defun sqlite3-result-double @var{context} @var{retval}
Set the result of a call to a custom @sql{} function to the flonum
@var{retval}; return unspecified values.
@end defun


@defun sqlite3-result-int @var{context} @var{retval}
Set the result of a call to a custom @sql{} function to the exact
integer @var{retval}, which must be in the range of the C language type
@code{int}; return unspecified values.
@end defun


@defun sqlite3-result-int64 @var{context} @var{retval}
Set the result of a call to a custom @sql{} function to the exact
integer @var{retval}, which must be in the range of the C language type
@code{sqlite3_int64}; return unspecified values.
@end defun

@c ------------------------------------------------------------

@subsubheading Textual return values


@defun sqlite3-result-text @var{context} @var{text.data} @var{text.start} @var{text.len} @var{destructor}
@defunx sqlite3-result-text16 @var{context} @var{text.data} @var{text.start} @var{text.len} @var{destructor}
@defunx sqlite3-result-text16le @var{context} @var{text.data} @var{text.start} @var{text.len} @var{destructor}
@defunx sqlite3-result-text16be @var{context} @var{text.data} @var{text.start} @var{text.len} @var{destructor}
Set the result of a call to a custom @sql{} function to a text string
represented as @utf{}-8, @utf{}-16 native byte order, @utf{}-16 little
endian or @utf{}-16 big endian; return unspecified values.

The string is described by @var{text.data}, @var{text.start} and
@var{text.len}.  @var{text.start} must be a non--negative exact integer,
in the range of the C language type @code{int}, representing the offset
from the beginning of @var{text.data} of the first @strong{byte} to
read.  The arguments are interpreted as follows:

@itemize
@item
If @var{text.data} is a bytevector and @var{text.len} is @false{}: the
string is set to the bytevector data from @var{text.start} to the end.

@item
If @var{text.data} is a bytevector and @var{text.len} is not @false{},
@var{text.len} must be an exact integer in the range of the C language
type @code{int}: the string is set to the first @var{text.len} bytes of
bytevector data starting at offset @var{text.start}.

@item
If @var{text.data} is a pointer object, @var{text.len} must be an exact
integer in the range of the C language type @code{int}: the string is
set to the first @var{text.len} bytes of the referenced memory block
starting at offset @var{text.start}.
@end itemize

If @var{destructor} is @false{}: the destructor is set to
@code{SQLITE_TRANSIENT}; else @var{destructor} must be a pointer object
referencing the destructor function to be used to finalise the string.
@end defun

@c ------------------------------------------------------------

@subsubheading Other return values

@defun sqlite3-result-null @var{context}
Set the result of a call to a custom @sql{} function to @code{NULL};
return unspecified values.
@end defun


@defun sqlite3-result-value @var{context} @var{retval}
Set the result of a call to the instance of @code{sqlite3_value}
referenced by @var{retval}, which must be an instance of
@code{sqlite3-value}; return unspecified values.

@var{retval} must be an instance of @code{sqlite3-value}.  @ref{plain
functions arguments, sqlite3-value}
@end defun

@c ------------------------------------------------------------

@subsubheading Returning errors


@defun sqlite3-result-error-code @var{context} @var{errcode}
Cause a call to a custom @sql{} function to raise a @sql{} exception;
return unspecified values.

@var{errcode} must be an exact integer representing one of the
@code{SQLITE_} error codes.  When this function is not used: the error
code is set to @code{SQLITE_ERROR}, which is good for most purposes.
@end defun


@defun sqlite3-result-error @var{context} @var{error-message}
@defunx sqlite3-result-error16 @var{context} @var{error-message}
Cause a call to a custom @sql{} function to raise a @sql{} exception;
return unspecified values.

@var{error-message} must be a string or bytevector, in @utf{}-8 or
@utf{}-16 encoding and native byte order, describing the error.
@end defun


@defun sqlite3-result-error-toobig @var{context}
Cause a call to a custom @sql{} function to raise a @sql{} exception;
return unspecified values.  The error description is set to ``text
string or @blob{} result to big to be represented''.
@end defun


@defun sqlite3-result-error-nomem @var{context}
Cause a call to a custom @sql{} function to raise a @sql{} exception;
return unspecified values.  The error description is set to ``memory
allocation failure''.
@end defun

@c page
@node plain functions aux
@subsection Auxiliary @sql{} functions operations


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-aggregate-context @var{context} @var{number-of-bytes}
Allocate and retrieve custom data associated with the context of an
application--defined @sql{} aggregate function; if custom data is
available: return a pointer object referencing it, else return @false{}.

@var{context} must be an instance of @code{sqlite3-context} representing
the context of the current function call.  @var{number-of-bytes} must be
a non--negative exact integer, in the range of the C language type
@code{int}, representing the number of bytes to allocate.

The first time this function is invoked in the context of a @sql{}
function call: the requested @var{number-of-bytes} is allocated and a
pointer to it returned; subsequent invocations to this function in the
same @sql{} function context just return the same pointer.

SQLite automatically releases the memory allocated by
@func{sqlite3-aggregate-context} when the aggregate query concludes.
@end defun


@defun sqlite3-user-data @var{context}
Return @false{} or a pointer object representing the @var{custom-data}
argument to the call to @func{sqlite3-create-function} used to generate
the @sql{} function associated to @var{context}.
@end defun


@defun sqlite3-context-db-handle @var{context}
Return a @code{sqlite3} instance representing the database connection
associated to @var{context}.  The returned value is valid only in the
extent of the current @sql{} function call.

The returned @code{sqlite3} instance does not ``own'' the database
connection: closing or garbage collecting it leaves the database
connection open, but finalises all the statements and @blob{}s that were
associated to it.

If we associate instances of @code{sqlite3-stmt} and/or
@code{sqlite3-blob} to the returned @code{sqlite3}: we @strong{must}
finalise them before returning from the application defined function.
@end defun


@defun sqlite3-set-auxdata @var{context} @var{argnum} @var{aux-data} @var{destructor}
Save the pointer object @var{aux-data} as auxiliary data associated to
the argument @var{argnum} to the current @sql{} function call associated
to @var{context}; such metadata can be later retrieved with
@func{sqteli3-get-auxdata}.  Return unspecified values.

@var{destructor} must be @false{} or a pointer object referencing a
callback function to be used to release the resources associated to
@var{aux-data}; when an object pointer: it should be the return value of
@func{make-sqlite3-auxdata-destructor}.
@end defun


@defun sqlite3-get-auxdata @var{context} @var{argnum}
Return @false{} or a pointer object representing the @var{aux-data}
argument to the call to @func{sqlite3-set-auxdata} for argument
@var{argnum} in the @sql{} function call associated to @var{context}.
@end defun


@defun make-sqlite3-auxdata-destructor @var{user-scheme-callback}
Wrap a user supplied Scheme function to produce a callback function
callable from C; return a pointer object referencing a callback function
suitable to be used as @var{destructor} argument in calls to
@func{sqlite3-set-auxdata}; the returned pointer must be released with a
call to @func{free-c-callback} from @library{vicare ffi}.

@var{user-scheme-callback} must accept a single argument: @false{} or a
pointer object equal to the argument @var{aux-data} in the call to
@func{sqlite3-set-auxdata}.

@var{user-scheme-callback} can return unspecified values.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}.  @var{user-scheme-callback} should take care of
handling its own exceptions.
@end itemize
@end defun

@c page
@node plain misc
@section Miscellaneous functions


The following bindings are exported by the @library{vicare databases
sqlite3} library.


@defun sqlite3-sleep @var{milliseconds}
Cause the current thread to suspend execution for at least a number of
@var{milliseconds}; return an exact integer representing the number of
milliseconds of sleep actually requested to the operative system.
@end defun


@defun sqlite3-log @var{error-code} @var{message}
Write a message into the error log established by the
@code{SQLITE_CONFIG_LOG} option to @func{sqlite3-config}.  Return
unspecified values.

@var{error-code} must be an exact integer.  @var{message} must be a
string or @utf{}-8 bytevector.
@end defun


@defun make-sqlite3-log-callback @var{user-scheme-function}
Wrap a user supplied Scheme function and return a pointer object
referencing a callback function suitable to be used as second argument
in calls to @func{sqlite3-config} with option @code{SQLITE_CONFIG_LOG};
the returned pointer must be released with a call to
@func{free-c-callback} from @library{vicare ffi}.

@var{user-scheme-callback} must accept two arguments:

@enumerate
@item
The @var{error-code} argument used in a call to @func{sqlite3-log}.

@item
A pointer object referencing a C language array holding a
zero--terminated @utf{}-8 representation of the @var{message} argument
to @func{sqlite3-log}; we can convert such data to a Scheme value using
@func{cstring->string} or @func{cstring->bytevector}.
@end enumerate

@var{user-scheme-callback} can return unspecified values.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}; when an exception is catched: it is discarded and the
callback returns the void value.  @var{user-scheme-callback} should take
care of handling its own exceptions.
@end itemize

@quotation
@strong{NOTE} The log callback can be registered and unregistered only
before initialising the SQLite library; so either we set it before doing
anything else or we call @func{sqlite3-shutdown} and then
@func{sqlite3-config}.
@end quotation
@end defun


@defun sqlite3-randomness @var{number-of-bytes}
Access SQLlite's pseudo--random numbers generator, allocate a new
bytevector of length @var{number-of-bytes} and fill it with
pseudo--random bytes; return such bytevector.
@end defun


@defun sqlite3-randomness! @var{bytevector}
Access SQLlite's pseudo--random numbers generator and fill
@var{bytevector} with pseudo--random bytes; return @var{bytevector}
itself.
@end defun


@defun sqlite3-error-code->symbol @var{code}
@defunx sqlite3-extended-error-code->symbol @var{code}
Given the exact integer @var{code} representing a @code{SQLITE_}
constant: return a symbol being the symbolic name of the constant.

@example
(sqlite3-error-code->symbol SQLITE_OK)
@result{} SQLITE_OK

(sqlite3-extended-error-code->symbol SQLITE_CANTOPEN_NOTEMPDIR)
@result{} SQLITE_CANTOPEN_NOTEMPDIR
@end example
@end defun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @url{http://marcomaggi.github.com/docs/vicare-sqlite.html}

@noindent
the latest version of this package can be downloaded from:

@center @url{http://github.com/marcomaggi/vicare-sqlite/downloads}

@noindent
development takes place at:

@center @url{http://github.com/marcomaggi/vicare-sqlite/}

@noindent
the home page of the Vicare project is at:

@center @url{http://marcomaggi.github.com/vicare.html}

@noindent
SQLite can be found here:

@center @url{http://www.sqlite.org/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

